/*
    This file is part of DIANA program (DIagram ANAlyser) $Revision: 2.37 $.
    Copyright (C) Mikhail Tentyukov <tentukov@physik.uni-bielefeld.de>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
    published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
/*To remove restriction on the order of fermionic interaction look for
FERMIONICORDERNOT2 below*/
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "tools.h"
#include "comdef.h"
#include "types.h"
#include "variabls.h"
#include "headers.h"
#include "texts.h"
#include "tt_type.h"
#define stINIT 0
#define stEND 1

#define stBEGINID 2
#define stESC 3
#define stINPUT 4
#define stLOG 5
#define stNUMBER 6
#define stFUNCTIONS 7
#define stCOMMUTING 8
#define stMOMENTUM 9
#define stINDICES 10
#define stVECTORS 11
#define stINGOING 12
#define stOUTGOING 13
#define stTOPOLOGY 14
#define stBEGINTRUNSLATE 15
#define stFUNCTIONSRESET 16
#define stCOMMUTINGRESET 17
#define stVECTORSRESET 20
#define stTOPOLOGIESRESET 21
#define stPROTOTYPESRESET 22
#define stIDRESET 23
#define stVARIABLESRESET 24
#define stEXPORTSRESET 25
#define stINDEX 26
#define stREADSEPARATOR 27
#define stREADIND 28
#define stREADVEC 29
#define stDIGIT_OR_VEC 30
#define stOPERATION 31
#define stOPER_OR_SEPAR 32
#define stDIGIT 33
#define stFERMION 34
#define stREADID 35
#define stEXTERNALLINES 36
#define stSPECMODE 37
#define stCOUNTER 38
#define stVL_NUMBER_RESET 39
#define stF_COUNTER_RESET 40
#define stFROMVERTEX 41
#define stTOVERTEX 42
#define stMESSAGES 43
#define stFORCED 44
#define stPARAMETER 45
#define stEXTRA 46
#define stONLYINTERPRET 47
#define stREPEAT 48
#define stDEBUG 49
#define stINCLUDESRESET 50
#define stMACROSESRESET 51
#define stSET_RESET 52
#define stSYSTPATH 53
#define stSELECT 54
#define stTADPOLES 55
#define stSET 56
#define stCOMMENT 57
#define stOUTFILE 58
#define stCHCOMMA 59
#define stOUTLINES 60
#define stCOORDINATES 61
#define stGENERICTOPOLOGY 62
#define stLINEMARKS 63
#define stGTOPOLOGIESRESET 64
#define GETFROMGENERIC 65
#define stMAXCOUPLINGORDER 66
#define stLINEVERTMARK_ID 67
#define stVERTEXMARKS 68
#define stMAXMARKLENGTH 69
#define stFLIP 70
#define stMAJORANA 71
#define stFLIPMOMENTA 72
#define stREMARKS 73
#define stEXTERNAL 74
#define stTOKEN 75
#define stLOOPMOMENTA 76
#define stZEROMOMENTUM 77
#define stIGNOREMOMENTA 78
#define stBRIDGESUBST 79
#define stCHORDSUBST 80
#define stSORTBYTYPE 81
#define stTRACE 82

static set_of_char valid_id;
static char **current_particles=NULL;
static char number_of_current_particle;
static char is_propagator;
static word current_id[MAX_LINES_IN_VERTEX];
static int empty_external_item=0;
/* The following static data are generated by make_topology:*/
static char **gtop_gname=NULL;/*Set of the the topology names*/
static int gtop_n_id=0;/*Number of entries in gtop_gname*/
static struct line_struct *gtop_ilines=NULL,*gtop_elines=NULL;/*topology
   with the redices lines*/
static int *gtop_lines=NULL;/* array of the length gtop_lines[0]+1: if 0,
   non-contracted, if 1, contracted. gtop_lines[0] is the length
   of the array 'gtop_lines'.*/
static int *gtop_lnums=NULL;/* array of the length gtop_lnums[0]+1: indices
      of lines corresponding to the original topology*/
static int *gtop_vnums=NULL;/* array of the length gtop_vnums[0]+1: indices
      of vertices corresponding to the original topology*/
static int gtop_n_generic=0;/* the number of the generic topology under
          consideration.*/

static char readp(char *str)
{
 int i;
 char control;
   control=*str;/*If *str==1, we will control is there index at particle*/
   if(*sc_get_token(str)!=':')
      halt(COLEXPECTED,str);

   i=str2long(sc_get_token(str));

    i--;
    if((i<0)||(!(i<number_of_current_particle)))
       halt(INVALIDNUMBER,str);
    if(control){/* Check the index of the correspomdimg particle*/
       control=i;/* Use control as (char)i !!!*/
       str=id[  id[ current_id[i] ].link[1]  ].form_id;
       while(*str){
          if(*str==3){/*vector*/
             str+=2;/*Skip particle id and number of vectors*/
             while(*str++!='\n');/*Skip to the end of vectors*/
          }
          if(*str==2)return(control);
          str++;
       }
       /*Control can't reach this point!*/
       halt(REQPARTWITHOUTIND,NULL);
    }
    control=i;
    return(control);
}/*readp*/

static char *readv(int *l,char *str)
{
 char *ptr=str+1;
 char buf[MAX_STR_LEN];
 char *tmp;
   *str=1;
   *ptr=0;

   do{
      if(*sc_get_token(buf) == '!' )/*NOT this vector*/
         tmp=sc_get_token(buf+1);
      else
         tmp=buf;

      /*Re-define tmp to the table value to use it in g_vectorsInTheMode*/
      if( (tmp=lookup(tmp,vectors_table))==NULL)
         halt(UNDEFINEDID,tmp);
      
      /*Now we add the vector to the array g_vectorsInTheModel.
        This array is used by procedure macallVectors.
        Note, usually only one or two vectors appear in the model!
        So we use linear algorithms here.*/
      {/*Block*/
         int i;
         for(i=0; i<g_topVectorsInTheModel; i++)
            if(s_scmp(g_vectorsInTheModel[i],tmp)==0)/*found*/
               break;
         if(i==g_topVectorsInTheModel){/*Not found*/
            if(
               (
                 g_vectorsInTheModel=
                  realloc(g_vectorsInTheModel,(++g_topVectorsInTheModel)*sizeof(char*))
               )==NULL
              )halt(NOTMEMORY,NULL);
            g_vectorsInTheModel[i]=tmp;
         }/*if(i==g_topVectorsInTheModel)*/
      }/*Block*/
      if(((*l)+=(s_len(buf)+1))>MAX_STR_LEN)
         halt(TOOLONGSTRING,NULL);
      s_let(buf,ptr);
      (*str)++;
      while(*ptr)ptr++;
      *ptr++=1;
   }while(*sc_get_token(buf)==comma_char);
   if(*buf!='}')
      halt(FBREXPECTED,buf);
   *ptr++='\n'; *ptr=0;
   return(str);
}/*readv*/

static int is_index_id(char *str)
{
   int i;
   for(i=0; i<numberOfIndicesGroups; i++)
       if(!s_scmp(index_id[i],str))return(i);
   return(-1);
}/*is_index_id*/

static  HASH_TABLE id_replace_table=NULL;

/*Reading form_id into 'buf'. Sets proper id[top_id] fields Nnum, Nmark, Nind,
  Nfnum, Nfflow, Nfromv, Ntov, Nvec. Returns -1 if it is function, or +1, if it
  is commuting. ATTENTION! It uses global variable top_id to access to id[top_id]:*/
static char read_form_id(char *str, char *buf)
{
  char *ptr=buf+1;
  int l=2;
  int balance=0;
  int gindex;
  char f_or_c=0;/*-1--functions, +1 -- commuting, 0 -- not defined yet.*/
     *buf=0;
     *ptr=0;
     do{
        if (!set_in(*sc_get_token(str),valid_id))
           halt(INVALIDBEGINOFID,str);
        if(f_or_c==0){
           if(lookup(str,all_functions_table)!=NULL)
              f_or_c=-1;
           else if(lookup(str,all_commuting_table)!=NULL)
              f_or_c=1;
           else
              halt(UNDEFINEDID,str);
        }else if (f_or_c==-1){
           if(lookup(str,all_functions_table)==NULL){
              if(lookup(str,all_commuting_table)!=NULL)
                 halt(DISAGREEMENT,str);
              else
                 halt(UNDEFINEDID,str);
           }
        }else{/*+1*/
           if(lookup(str,all_commuting_table)==NULL){
              if(lookup(str,all_functions_table)!=NULL)
                 halt(DISAGREEMENT,str);
              else
                 halt(UNDEFINEDID,str);
           }
        }
        if( (l+=(s_len(str)+1))>MAX_STR_LEN)
          halt(TOOLONGSTRING,NULL);
        s_let(str,ptr);
        while(*ptr)ptr++;
        *ptr++=1;
        (*buf)++;
     }while(*sc_get_token(str)==':');
     *ptr++='\n';*ptr=0;
     if((*str==';')||(*str==']')) return(f_or_c);
     if (*str=='[')
        balance=1;
     else if (*str!='(')
        halt(UNEXPECTED,str);
     *ptr++=*str;*ptr=0;
     do{
        gindex=-1;
        while(1){
           if( (*sc_get_token(str)==';')||
               ((*str==']')&&(balance==0))||
               (lookup(str,id_replace_table)!=NULL)
           )break;

           if( (l+=(s_len(str)+1))>MAX_STR_LEN)
             halt(TOOLONGSTRING,NULL);
           if(*str=='[')balance++;
           else if(*str==']')balance--;
           s_let(str,ptr);
           while(*ptr)ptr++;
        }/*while(1)*/
        if(*str==';') return(f_or_c);
        if(*str==']'){
           if(!is_propagator)
              return(f_or_c);
           else
              halt(SEMICOLEXP,str);
        }
        if(!s_scmp(str,vl_counter_id)){
           if((l+=4)>MAX_STR_LEN)
              halt(TOOLONGSTRING,NULL);
           s_let(p11,ptr);
           ptr+=3;
           (id[top_id].Nnum)++;
        }else if(!s_scmp(str,lm_counter_id)){
           if((l+=max_marks_length)>MAX_STR_LEN)
              halt(TOOLONGSTRING,NULL);
           s_let(p15,ptr);
           ptr+=(max_marks_length-1);
           (id[top_id].Nmark)++;
        }else if(!s_scmp(str,f_counter_id)){
           if((l+=4)>MAX_STR_LEN)
              halt(TOOLONGSTRING,NULL);
           s_let(p12,ptr);
           ptr+=3;
           (id[top_id].Nfnum)++;
        }else if(!s_scmp(str,fflow_counter_id)){
           if((l+=4)>MAX_STR_LEN)
              halt(TOOLONGSTRING,NULL);
           s_let(p16,ptr);
           ptr+=3;
           (id[top_id].Nfflow)++;
        }else if(!s_scmp(str,from_counter_id)){
           if(!is_propagator)
              halt(ONLYFORPROPAGATORS,str);
           if((l+=4)>MAX_STR_LEN)
              halt(TOOLONGSTRING,NULL);
           s_let(p13,ptr);
           ptr+=3;
           (id[top_id].Nfromv)++;
        }else if(!s_scmp(str,to_counter_id)){
           if(!is_propagator)
              halt(ONLYFORPROPAGATORS,str);
           if((l+=4)>MAX_STR_LEN)
              halt(TOOLONGSTRING,NULL);
           s_let(p14,ptr);
           ptr+=3;
           (id[top_id].Ntov)++;
        }else if(  (gindex=is_index_id(str))!=-1){
           if((l+=3)>MAX_STR_LEN)
              halt(TOOLONGSTRING,NULL);
           *ptr++='\2';
           *str=!is_propagator;
           *ptr++=readp(str)+'0';
           *ptr++=gindex+'0';
           *ptr='\0';
           (id[top_id].Nind)++;
        }else{/*Only momentum_id may be*/
           (id[top_id].Nvec)++;
           if(is_propagator){/*Put here "\3\127"*/
              if((l+=2)>MAX_STR_LEN)
                 halt(TOOLONGSTRING,NULL);
              *ptr++=3;*ptr++=127;*ptr=0;
           }else{/*Put here "\3#", where # is ASCII number of a particle*/
              /*!!! Use particle id instead of propagator id into momenta
              distributing:*/
              /*addrr=id[readp(str)].link[1];*//*Link[1]-address of propagator.*/
              if((l+=2)>MAX_STR_LEN)
                 halt(TOOLONGSTRING,NULL);
              *ptr++=3;
              *str=0;
              *ptr++=readp(str)+'0';
              *ptr=0;
           }
           sc_mark();
           if(*sc_get_token(str)=='{'){
              sc_release();
              s_let(readv(&l,str),ptr);
              while(*ptr)ptr++;
           }else{
              l+=2;
              *ptr++=1;*ptr++='\n';*ptr=0;
              sc_repeat();
           }
        }/* .. else ..  Only momentum_id may be*/
     }while(1);

}/*read_form_id*/

static char *read_file_name(char *str)
{
 char tmp[MAX_STR_LEN], old_esc=esc_char;

   *str=0;
   esc_char='"';hash_enable=0;
   sc_get_token(str);
   esc_char=old_esc;
   if (*sc_get_token(tmp)!='\"')
      halt(QUOTEXPECTED,tmp);
   return(str);
}/*read_file_name*/

static int pcounter=0;
static void read_model(char *str)
{
 char buf[MAX_STR_LEN];

 char *tmp;
 word *ptr;

 int i;
 char f_or_c;
  if(!set_in(*sc_get_token(current_particles[0]),valid_id))
     halt(INVALIDBEGINOFID,s_let(current_particles[0],str));
  if(*sc_get_token(str)!=comma_char)
     halt(COMMAEXPECTED,str);
  if(!set_in(*sc_get_token(current_particles[1]),valid_id))
     halt(INVALIDBEGINOFID,s_let(current_particles[1],str));
  if(*sc_get_token(str)==';'){/*Propagator*/
     is_propagator=1;
     number_of_current_particle=2;
     /* If both particles are the same, store only first*/
     i=(!s_scmp(current_particles[0],current_particles[1]));
     /* If i==1, particle is equal to anti-*/
     /*First particle process:*/
     current_id[0]=alloc_id();
     set_id(s_cat(str,"\1",current_particles[0]));
     id[top_id].link[0]=(i)?(top_id):(top_id+1);/*Second particle*/
     id[top_id].link[1]=(i)?(top_id+1):(top_id+2);/*Propagator*/
     id[top_id].kind=!i;/*begin of propagator or undistinguishing.*/
     if(i){
        current_id[1]=top_id;/*The same particle.*/
        s_let(str,buf);/*Do not forget second particle!*/
     }
     top_id++;
     if(!i){
         /*Second particle process:*/
         current_id[1]=alloc_id();
         set_id(s_cat(buf,"\1",current_particles[1]));
         id[top_id].link[0]=top_id-1;/*First particle*/
         id[top_id].link[1]=top_id+1;/*Propagator*/
         id[top_id].kind=2;/*end of propagator*/
         top_id++;
     }
     /*Propagator process:*/
     alloc_id();
     set_id(m_cat(str,str,buf));
     id[top_id].link[0]=(i)?(top_id-1):(top_id-2);/*First particle*/
     id[top_id].link[1]=top_id-1;/*Second particle*/
     /*Fields kind, type,form_id and mass are not defined yet.*/
  }else if(*str==comma_char){/*Vertex*/
     is_propagator=0;
     *buf=0;
     if((ptr=lookup(s_cat(str,"\1",current_particles[0]),
          main_id_table ))==NULL)
            halt(UNDEFINEDID,str+1);
     m_cat(buf,buf,str);
     current_id[0]=*ptr;
     if((ptr=lookup(s_cat(str,"\1",current_particles[1]),
               main_id_table))==NULL)
                   halt(UNDEFINEDID,str+1);
     m_cat(buf,buf,str);
     current_id[1]=*ptr;
     number_of_current_particle=2;
     do{
        if(!(number_of_current_particle<MAX_LINES_IN_VERTEX))
           halt(TOOMANYPARTINVERT,NULL);
        s_let(sc_get_token(str),current_particles[number_of_current_particle]);
        if((ptr=lookup(s_cat(str,"\1",
                current_particles[number_of_current_particle]),
                main_id_table
                ))==NULL)
                   halt(UNDEFINEDID,str+1);
        current_id[number_of_current_particle++]=*ptr;
        m_cat(buf,buf,str);
     }while(*sc_get_token(str)==comma_char);
     if (*str!=';')
        halt(SEMICOLEXP,str);
     alloc_id();
     set_id(buf);
     {/*Block*/
        int n=0;
        for(i=0;i<number_of_current_particle;i++){
           id[top_id].link[i]=current_id[i];
           if(id[id[current_id[i]].link[1]].kind==-1)
              n++;           
        }/*for(i=0;i<number_of_current_particle;i++)*/
        if(n){
           f_or_c=-1;
           if( n != 2 )/*Order of fermionic interaction !=2*/
              halt(FERMIONICORDERNOT2,n);
        }else
           f_or_c=1;
     }/*Block*/
     /*Fields kind, type,form_id and mass are not defined yet.*/
  }else
     halt(UNEXPECTED,str);
  /*Fields kind, type,form_id and mass are not defined yet.*/
  /*top_id points to current cell.*/
  /*Reading type:*/
  if(*sc_get_token(str)==';'){/*Empty type*/
     id[top_id].type=(is_propagator)?'!':'#';
  }else{
     id[top_id].type=*(str);
     if(str[1])
        halt(ONLYONECHARACTERALLOWED,str);
     if (is_propagator)l_type=1;else v_type=1;
     if(*sc_get_token(str)!=';')
        halt(SEMICOLEXP,str);
  }
  if(is_propagator){/*Set the same type for both particles:*/
    id[ id[top_id].link[0]  ].type=id[top_id].type;
    id[ id[top_id].link[1]  ].type=id[top_id].type;
  }
  /*Reading form_id into 'buf'. Sets proper id[top_id] fields Nnum, Nmark, Nind,
    Nfnum, Nfflow, Nfromv, Ntov, Nvec. Returns -1 if it is function, or +1, if it
    is commuting. ATTENTION! It uses global variable top_id to access to id[top_id]:*/
  id[top_id].kind=read_form_id(str, buf);
  /*In buf is form id.*/

  id[top_id].form_id=new_str(buf);
  /*If propagator, check indices (0 or 2) and read its mass:*/
  if(is_propagator){
     char **fonts=NULL;
     char *img=NULL;
     i=0;
     tmp=buf+1;/*Avoid first character:it may be 2*/
     while(*tmp){
        if(*tmp==3){/*vector*/
           tmp+=2;/*Skip particle id and number of vectors*/
           while(*tmp++!='\n');/*Skip to the end of vectors*/
        }
        if(*tmp==2)
           set_bit(&i,tmp[1]-'0');
        tmp++;
     }
     if(i)if(!(is_bit_set(&i,0)&&is_bit_set(&i,1)))
       halt(WRONGNUMBEROFINDICESINPROPAGATOR,NULL);
     id[top_id].mass=new_str(sc_get_token(str));
     /* Now we can (optionally) read drawing line type for propagator:*/
     if (*sc_get_token(buf)!=']'){/* Yes, try to read: type,param,thickness:*/
        double param,thickness;
        pcounter++;
        if (*buf!=';')
           halt(SBREXPECTED,buf);
        if(
          (s_scmp(sc_get_token(buf),"wavy")!= 0)&&
          (s_scmp(buf,"arrowWavy")!= 0)&&
          (s_scmp(buf,"spiral")!= 0)&&
          (s_scmp(buf,"arrowSpiral")!= 0)&&
          (s_scmp(buf,"line")!= 0)&&
          (s_scmp(buf,"arrowLine")!= 0)&&
          (s_scmp(buf,"nothing")!= 0)
        )
             halt(UNKNOWNLINETYPE,buf);

        if(*sc_get_token(str)!=',')
           halt(COMMAEXPECTED,str);
        if( sscanf(sc_get_token(str),"%lf",&param)!=1){
           if(sscanf(str,"%d",&i)!=1)
              halt(CANNOTCONVERTTONUMBER,str);
            param=i;
        }
        if(*sc_get_token(str)!=',')
          halt(COMMAEXPECTED,str);
        if( sscanf(sc_get_token(str),"%lf",&thickness)!=1){
           if(sscanf(str,"%d",&i)!=1)
              halt(CANNOTCONVERTTONUMBER,str);
           thickness=i;
        }
        sprintf(str,"_PSRaw_%dp",pcounter);
        set_export_var(str,current_particles[0]);
        sprintf(str,"%.2f %.2f %s",param,thickness,buf);
        sprintf(buf,"_PSRaw_%dv",pcounter);
        set_export_var(buf,str);
        /*Is that all?*/
        if (*sc_get_token(str)!=']'){/*Read particle image instructions:*/
           int nb;
           char *inp=NULL;
           if (*str!=';')
              halt(SBREXPECTED,str);
           /*Collect a text up to ']':*/
           while(*sc_get_token(str)!=']'){
              if(*str=='"')
                 inp=s_inc(inp,read_file_name(str));
              else
                 inp=s_inc(inp,str);
           }/*while(sc_get_token(str)!=']')*/
           if(inp==NULL)/* it MAY be NULL, compare ';]'*/
              inp=new_str("");

           /* Here we have ready collected image code.*/
           /* Not so long ?:*/
           if(s_len(inp)>MAX_IMG_LEN){
              free(inp);halt(TOOLONGSTRING,NULL);
           }/*if(s_len(inp)>MAX_IMG_LEN)*/

           /*Parse collected string and build the PostScript instruction set
             (output is in 'img'):*/
           nb=parse_particle_image(FSIZE,MULTIPLIER,SHOW,inp,&img,&fonts);

           if(nb<0){/* Parsing error*/
              int i;
              s_let(inp,str);
              free(inp);
              nb=-nb-1;/*nb is a position at which parsing failes*/
              for(i=0;i<nb;i++)buf[i]=' ';
              buf[i++]='^';buf[i]='\0';
              /* on error, img is a pointer to a STATIC string containing diagnostics:*/
              halt("%s:\n%s\n%s ",img,str,buf);
           }/*if(nb<0)*/
           free_mem(&inp);/*Not need input*/

           if(fonts!=NULL){
              /*Set information about each font (export var _PSRaw_#f# font)*/
              int i;
              for(i=0;fonts[i]!=NULL;i++){
                 sprintf(buf,"_PSRaw_%df%d",pcounter,i+1);
                 set_export_var(buf,fonts[i]);
                 free(fonts[i]);
              }/*for(i=0;fonts[i]!=NULL;i++)*/
              /*Do not clear fonts here! Will be used as an indicator and
                cleared further*/
              /*_PSRaw_#f contains the number of fonts used*/
              sprintf(buf,"_PSRaw_%df",pcounter);
              sprintf(str,"%d",i);
              set_export_var(buf,str);
           }/*if(fonts!=NULL)*/
           /*Will be stored in statically allocated buffer:*/
           if(s_len(img)>MAX_STR_LEN-64){
              free(fonts);free(img);halt(TOOLONGSTRING,NULL);
           }/*if(s_len(img)>MAX_STR_LEN-64)*/

           /*Build a PS code to draw an image:*/
           sprintf(str,"{%s}",img);

           /* !*! - see several lines below:*/
           /*
           free(img);
           */

           sprintf(buf,"_PSRaw_%di",pcounter);
           set_export_var(buf,str);
           /*Do NOT clear img here! It will be used as an indicator and cleared
             a few lines below*/

        }/*if (*sc_get_token(str)!=']')...else*/
        if(img==NULL){/*Store '(beginpropagator) show' as a particle image*/
           sprintf(str,"{(%s) %s}",current_particles[0],SHOW);
           sprintf(buf,"_PSRaw_%di",pcounter);
           set_export_var(buf,str);
        }else/*if(img==NULL)*/
           free_mem(&img);
        /*ATTENTION! This branch is passed only if there are at least drawing parameters!
          If they are absent, then there are no Raw parameters for the corresponding
          particle at all, and _PS parameters will be set by mac_PDiaImages/mac_PAllImages,
          see macro.c
         */
     }/*if (*sc_get_token(buf)!=']')*/
     if(fonts!=NULL)
        free_mem(&fonts);
     else{/*No non-standart fonts*/
        sprintf(str,"_PSRaw_%df",pcounter);
        set_export_var(str,"0");
     }/*if(fonts!=NULL) ... else*/

     /*For vertex the character ']' is already read.*/
  }else{/*Check agreement of vertex with propagators*/
    if(id[top_id].kind!=f_or_c){
      for(i=1;buf[i]>' ';i++);
      buf[i]=0;
      halt(DISAGREEMENT,buf+1);
    }/*if(id[top_id].kind!=f_or_c)*/
  }/*if(is_propagator)...else*/
  /*Increase current top:*/
  top_id++;
}/*read_model*/

static char read_momentum_group(int *pos,char *str)/* Returns 0 if
                      group is not last, or last scanned nongroup character*/
{
  char tmp[MAX_STR_LEN];
  MOMENT *cell;/*We will use cell into vec_group array. If further it appears
                 that this group already exists, we will not increas
                 top_vec_group.*/
  int state,*ptr;
  word len=2;

  *tmp=0;*pos=0;
  for(state=stINIT;state!=stEND;)switch(state){/*Begin finite automaton*/
     case stINIT:
        if((*sc_get_token(str)=='+')||(*str=='-')){
           *pos=(*str=='+')?1:-1;
           sc_get_token(str);
        }else{
           *pos=1;
        }
        if(!(top_vec_group<max_top_vec_group))
           if(
             (vec_group=realloc(vec_group,
                (max_top_vec_group+=MAX_VEC_GROUP)*sizeof(MOMENT)))==NULL
             )halt(NOTMEMORY,NULL);
        cell=vec_group+top_vec_group;
        cell->vec=NULL;
        cell->text=NULL;
        /*No break!*/
     case stDIGIT_OR_VEC:
        if(state!=stINIT)sc_get_token(str);
        if(is_digits(str)){
          if((len+=s_len(str))>MAX_STR_LEN) halt(TOOLONGSTRING,NULL);
          s_cat(tmp, tmp, str);
          state=stOPERATION;
        }else if(lookup(str,vectors_table)!=NULL){
          if(cell->vec!=NULL) halt(UNEXPECTED,str);
          if((len+=s_len(str))>MAX_STR_LEN) halt(TOOLONGSTRING,NULL);
          s_cat(tmp, tmp, str);
          cell->vec=new_str(str);
          state=stOPER_OR_SEPAR;
        }else halt(UNEXPECTED,str);
        break;
     case stOPERATION:
        if((*sc_get_token(str)=='*')||(*str=='/')){
          if((len+=s_len(str))>MAX_STR_LEN) halt(TOOLONGSTRING,NULL);
          s_cat(tmp, tmp, str);
          state=stDIGIT_OR_VEC;
        }else halt(UNEXPECTED,str);
        break;
     case stOPER_OR_SEPAR:
        sc_mark();
        if((*sc_get_token(str)=='*')||(*str=='/')){
           sc_release();
           if((len+=s_len(str))>MAX_STR_LEN) halt(TOOLONGSTRING,NULL);
           s_cat(tmp, tmp, str);
           state=stDIGIT;
        }else{
          sc_repeat();
          state=stEND;
        }
        break;
     case stDIGIT:
       if(!is_digits(sc_get_token(str)))
          halt(UNEXPECTED,str);
       if((len+=s_len(str))>MAX_STR_LEN) halt(TOOLONGSTRING,NULL);
       s_cat(tmp, tmp, str);
       state=stOPER_OR_SEPAR;
       break;
  }/*end finite automaton*/
  if(cell->vec==NULL) halt(SYNTAXERROR,NULL);
  if(vec_group_table==NULL)
    vec_group_table=create_hash_table(vec_group_hash_size,
                                        str_hash,str_cmp,int_destructor);
  if((ptr=lookup(tmp, vec_group_table))==NULL){/*Such cell absent, store it:*/
     cell->text=new_str(tmp);
     (*pos)*=top_vec_group++;
     *(ptr=get_mem(1,sizeof(int)))=abs(*pos);
     install(cell->text,ptr,vec_group_table);
  }else{
     free_mem(&(cell->vec));/* Reset cell*/
     (*pos)*=(*ptr);/*Store pozition and sign*/
  }
  if((*str=='+')||(*str=='-')) return(0);
  return(*str);
}/*read_momentum_group*/

static void clear_topology(aTOPOL *topologies,word i)
{
word j,k;
     if (topologies[i].topology!=NULL){
        if(topologies[i].momenta!=NULL){
           for(k=0; k<topologies[i].n_momenta;k++){
              for(j=1; !(j>(topologies[i].topology)->i_n); j++)
                 free_mem(&(topologies[i].momenta[k][j]));
              free_mem(&(topologies[i].momenta[k]));
           }
           free_mem(&(topologies[i].momenta));
        }/*if(topologies[i].momenta!=NULL)*/
        if(topologies[i].linemarks != NULL){

           k=(topologies[i].topology)->i_n;
           for(j=0; !(j>k);j++)
              free_mem( &(topologies[i].linemarks[j]));
           free_mem( &(topologies[i].linemarks));
        }
        if(
            (topologies[i].vertexmarks != NULL)&&
            (  (k=topologies[i].max_vertex)>0  )
          ){
           for(j=0; !(j>k);j++)
              free_mem( &(topologies[i].vertexmarks[j]));
           free_mem( &(topologies[i].vertexmarks));
        }

     }/*if (topologies[i].topology!=NULL)*/
     if(topologies[i].ext_momenta!=NULL){
           for(k=0; k<topologies[i].n_momenta;k++){
              if (topologies[i].ext_momenta[k] == NULL )
                 continue;
              for(j=1; !(j>(topologies[i].topology)->e_n); j++)
                 free_mem(&(topologies[i].ext_momenta[k][j]));
              free_mem(&(topologies[i].ext_momenta[k]));
           }
           free_mem(&(topologies[i].ext_momenta));
     }
     free_mem(&(topologies[i].topology));
     free_mem(&(topologies[i].orig));
     if(topologies[i].id!=NULL){
           for(k=0; k<topologies[i].n_id;k++)
              free_mem(&(topologies[i].id[k]));
     }
     free_mem(&(topologies[i].id));
     free_mem(&(topologies[i].l_subst));
     free_mem(&(topologies[i].v_subst));
     free_mem(&(topologies[i].l_dir));

     free_mem(&(topologies[i].ev));  /* external vertices */
     free_mem(&(topologies[i].evl)); /* external vertices labels*/
     free_mem(&(topologies[i].iv));  /* internal vertices*/
     free_mem(&(topologies[i].ivl)); /* internal vertices labels*/
     free_mem(&(topologies[i].el));  /* external lines */
     free_mem(&(topologies[i].ell)); /* external lines labels */
     free_mem(&(topologies[i].il));  /* internal lines */
     free_mem(&(topologies[i].ill)); /* internal lines labels */
     free_mem(&(topologies[i].rad));
     free_mem(&(topologies[i].ox));
     free_mem(&(topologies[i].oy));
     free_mem(&(topologies[i].start_angle));
     free_mem(&(topologies[i].end_angle));

     if(topologies[i].remarks!=NULL){
        k=topologies[i].top_remarks;
        for(j=0;j<k;j++){
              free_mem(&(topologies[i].remarks[j].name));
              free_mem(&(topologies[i].remarks[j].text));
        }/*for(j=0;j<top_remarks;j++)*/
        free_mem(&(topologies[i].remarks));
     }/*if(topologies[i].remarks!=NULL)*/

}/*clear_topology*/

static void clear_gtopologies_tables(void)
{
int i;
    for(i=0;i<top_gtopol;i++){
      clear_topology(gtopologies,i);
    }
    top_gtopol=max_top_gtopol=0;
    free_mem(&gtopologies);
    if (gtopologies_table!=NULL){
       hash_table_done(gtopologies_table);
       gtopologies_table=NULL;
    }
    if (gtopology_id_table!=NULL){
       hash_table_done(gtopology_id_table);
       gtopology_id_table=NULL;
    }
}/*clear_gtopologies_tables*/

static void terr(aTOPOL *topologies,word top_topol,char *s1, char *s2)
{
  if (topologies!=NULL){
     clear_topology(topologies,top_topol);
  }
  halt(s1,s2);
}/*terr*/

static void read_topology(int state,  char *str)

{
   int i;
   aTOPOL **Topologies;
   word *Top_topol;
   word *Max_top_topol;
   word Topology_hash_size;
   char *defaulttopologyid;/*template life "t%d_"*/
   char *additionaltopologyid;/*template life "t%dA%d_"*/
   HASH_TABLE *Topology_id_table;
   HASH_TABLE *Usertopologies_table;

   switch(state){
     case GETFROMGENERIC:
     case stTOPOLOGY:
          Topologies=&topologies;
          Top_topol=&top_topol;
          Max_top_topol=&max_top_topol;
          defaulttopologyid=DEFAULTTOPOLOGYID;
          additionaltopologyid=ADDITIONALTOPOLOGYID;
          Topology_id_table=&topology_id_table;
          Usertopologies_table=&usertopologies_table;
          Topology_hash_size=topology_hash_size;
          break;
     case stGENERICTOPOLOGY:
          Topologies=&gtopologies;
          Top_topol=&top_gtopol;
          Max_top_topol=&max_top_gtopol;
          defaulttopologyid=DEFAULTgTOPOLOGYID;
          additionaltopologyid=ADDITIONALgTOPOLOGYID;
          Topology_id_table=&gtopology_id_table;
          Usertopologies_table=&gtopologies_table;
          Topology_hash_size=gtopology_hash_size;
          break;
     default:
        halt(INTERNALERROR,NULL);
   }

   if (!(*Top_topol < *Max_top_topol))
     if(
         (*Topologies=realloc(*Topologies,
                ((*Max_top_topol)+=Topology_hash_size)*sizeof(aTOPOL)))==NULL
             )halt(NOTMEMORY,NULL);

   (*Topologies)[(*Top_topol)].topology=NULL;
   (*Topologies)[(*Top_topol)].orig=NULL;
   (*Topologies)[(*Top_topol)].id=NULL;
   (*Topologies)[(*Top_topol)].n_id=0;
   (*Topologies)[(*Top_topol)].momenta=NULL;
   (*Topologies)[(*Top_topol)].ext_momenta=NULL;
   (*Topologies)[(*Top_topol)].n_momenta=0;
   (*Topologies)[(*Top_topol)].max_vertex=0;
   (*Topologies)[(*Top_topol)].label=0;
   (*Topologies)[(*Top_topol)].num=(*Top_topol);
   (*Topologies)[(*Top_topol)].l_subst=NULL;
   (*Topologies)[(*Top_topol)].v_subst=NULL;
   (*Topologies)[(*Top_topol)].l_dir=NULL;
   (*Topologies)[(*Top_topol)].linemarks=NULL;
   (*Topologies)[(*Top_topol)].vertexmarks=NULL;
   /*Coordinates, relate to user topology:*/
   (*Topologies)[(*Top_topol)].ev=NULL;  /* external vertices */
   (*Topologies)[(*Top_topol)].evl=NULL; /* external vertices labels*/
   (*Topologies)[(*Top_topol)].iv=NULL;  /* internal vertices*/
   (*Topologies)[(*Top_topol)].ivl=NULL; /* internal vertices labels*/
   (*Topologies)[(*Top_topol)].el=NULL;  /* external lines */
   (*Topologies)[(*Top_topol)].ell=NULL; /* external lines labels */
   (*Topologies)[(*Top_topol)].il=NULL;  /* internal lines */
   (*Topologies)[(*Top_topol)].ill=NULL; /* internal lines labels */
   (*Topologies)[(*Top_topol)].rad=NULL;
   (*Topologies)[(*Top_topol)].ox=NULL;
   (*Topologies)[(*Top_topol)].oy=NULL;
   (*Topologies)[(*Top_topol)].start_angle=NULL;
   (*Topologies)[(*Top_topol)].end_angle=NULL;
   (*Topologies)[(*Top_topol)].remarks=NULL;
   (*Topologies)[(*Top_topol)].top_remarks=0;

   if (*Topology_id_table == NULL)
      (*Topology_id_table)=create_hash_table(Topology_hash_size,
                               str_hash,str_cmp,int_destructor);
   if (state == GETFROMGENERIC){
    set_bit(&((*Topologies)[(*Top_topol)].label),1);/* Make it as generated*/

    /* The following static data are generated by make_topology:
     * char **gtop_gname -- set of the the topology names
     * int gtop_n_id -- number of entries in gtop_gname
     * struct line_struct *gtop_ilines,gtop_elines -- topology
     * int *gtop_lines --  array of the length gtop_lines[0]+1: if 0,
     *    non-contracted, if 1, contracted. gtop_lines[0] is the length
     *    of the array 'gtop_lines'.
     * int *gtop_lnums --  array of the length gtop_lnums[0]+1: indices
     * of lines corresponding to the original topology
     * int *gtop_vnums --  array of the length gtop_vnums[0]+1: indices
     * of vertices corresponding to the original topology
     *
     * The following variable is an iteratorin sysle on all generic topologies:
     * int gtop_n_generic -- the number of the generic topology under
     *     consideration.
     */

    (*Topologies)[(*Top_topol)].n_id=gtop_n_id;
    /* Array gtop_gname was allocated in make_topology:*/
    (*Topologies)[(*Top_topol)].id=gtop_gname;
    gtop_gname=NULL;
    /* Now it belongs to the topology! */
    if(
       install(  (*Topologies)[(*Top_topol)].id[0],
                 newword(*Top_topol),
                 *Topology_id_table
              )
    )halt(DOUBLEDEF,(*Topologies)[(*Top_topol)].id[0]);
   }else if(*sc_get_token(str)=='='){
      /* The user does not define the identifier. Use default one:*/
      get_undefinedtopologyid(defaulttopologyid, additionaltopologyid,
                              Topology_id_table,Topology_hash_size, str, *Top_topol);

      (*Topologies)[(*Top_topol)].id=get_mem(1,sizeof(char*));
      (*Topologies)[(*Top_topol)].id[0]=new_str(str);
      (*Topologies)[(*Top_topol)].n_id=1;
      install((*Topologies)[(*Top_topol)].id[0],
      newword(*Top_topol),
      *Topology_id_table);
   }else{
      /* Read identifiers:*/
      /*Here we have in "str" the first (unique) identifier.*/
      /*Allocates space for pointers, maximal number first (will be reduced):*/
      (*Topologies)[(*Top_topol)].id=get_mem(MAX_TOPOLOGY_ID_SET,sizeof(char*));

      if(install(
           (
            (*Topologies)[(*Top_topol)].id[(*Topologies)[(*Top_topol)].n_id++]=
            new_str(str)
           ),
           newword(*Top_topol),
           *Topology_id_table)
      ) halt(DOUBLEDEF,(*Topologies)[(*Top_topol)].id[0]);

      while( *sc_get_token(str)!= '='){/*Here may be read '=' or ','*/
         if(*str != comma_char )
            halt(UNEXPECTED,str);

         if(!((*Topologies)[(*Top_topol)].n_id<MAX_TOPOLOGY_ID_SET))
            halt(TOOMANYTOPOLOGYIDSETS,NULL);
         (*Topologies)[(*Top_topol)].id[(*Topologies)[(*Top_topol)].n_id++]=
            new_str(sc_get_token(str));
      }/*while( *sc_get_token(str)!= '=')*/

      /*Reduce the array according to the actual size:*/
      if(
         (
           (*Topologies)[(*Top_topol)].id=realloc(
               (*Topologies)[(*Top_topol)].id,
               sizeof(char*)*(*Topologies)[(*Top_topol)].n_id
           )
         )==NULL
      )
       halt(NOTMEMORY,NULL);
   }

   (*Topologies)[(*Top_topol)].topology=get_mem(1, sizeof(tTOPOL));
   (*Topologies)[(*Top_topol)].orig=get_mem(1, sizeof(tTOPOL));

   if(state == GETFROMGENERIC){
      /*Just copy generated topology to (*Topologies)[(*Top_topol)].orig:*/
      ((*Topologies)[(*Top_topol)].orig)->i_n=gtop_lnums[0];
      ((*Topologies)[(*Top_topol)].orig)->e_n=ext_lines;
      for(i=0;!(i>gtop_lnums[0]);i++){
         (((*Topologies)[(*Top_topol)].orig)->i_line)[i].from=
                  gtop_ilines[i].from;
         (((*Topologies)[(*Top_topol)].orig)->i_line)[i].to=
                  gtop_ilines[i].to;
      }/*for(i=0;!(i>gtop_lnums[0]);i++)*/
      for(i=0;!(i>ext_lines);i++){
         (((*Topologies)[(*Top_topol)].orig)->e_line)[i].from=
                  gtop_elines[i].from;
         (((*Topologies)[(*Top_topol)].orig)->e_line)[i].to=
                  gtop_elines[i].to;
      }/*(i=0;!(i>ext_lines)*/
   }/*if(state == GETFROMGENERIC)*/
   {/*block*/
    char l_subst[MAX_I_LINE], v_subst[MAX_I_LINE], l_dir[MAX_I_LINE];
    /* read_topol() reads the topology from the scanner ONLY if it is not
     * defined yet, i.e., if (*Topologies)[(*Top_topol)].orig->e_n==i_n==0:*/
    reduce_topology(0,read_topol((*Topologies)[(*Top_topol)].orig,
                                       l_subst,v_subst, l_dir),
                                          (*Topologies)[(*Top_topol)].topology,
                                                     l_subst, v_subst,l_dir);
     (*Topologies)[(*Top_topol)].l_subst=new_str(l_subst);
     (*Topologies)[(*Top_topol)].v_subst=new_str(v_subst);
     (*Topologies)[(*Top_topol)].l_dir=new_str(l_dir);

     /* ATTENTION! The following function uses the contents of the
      * static variable tmp_topology!
      * This is nonsense, of course. It's a kinde of a patch:
      * The following function restores the original topology, broken by
      * read_topol(). The point is the function read_topol() does
      * not ONLY read the topology, but also makes some improvements...*/
     get_orig_topology((*Topologies)[(*Top_topol)].orig);
   }/*block*/

   (*Topologies)[(*Top_topol)].max_vertex=max_vertex;
   /* max_vertex comes from read_topol(...), see before*/
   if(state != stGENERICTOPOLOGY){/* No coordinates for generic topologies!*/
      /*Coordinates:*/
      allocate_topology_coordinates((*Topologies) +(*Top_topol));
   }

   /* Now do with momenta...*/
   if(state == GETFROMGENERIC){
     /* Just copy momenta from the generic topology according to gtop_lnums[0] */
     int j;
      (*Topologies)[(*Top_topol)].n_momenta=
          gtopologies[gtop_n_generic].n_momenta;
      (*Topologies)[(*Top_topol)].momenta=
         get_mem(gtopologies[gtop_n_generic].n_momenta,sizeof(int **));
      (*Topologies)[(*Top_topol)].ext_momenta=
         get_mem(gtopologies[gtop_n_generic].n_momenta,sizeof(int **));
      for(i=0;i<gtopologies[gtop_n_generic].n_momenta;i++){
         if(gtopologies[gtop_n_generic].ext_momenta[i]!=NULL)
            (*Topologies)[(*Top_topol)].ext_momenta[i]=
               get_mem(ext_lines+1,sizeof(int *));
         (*Topologies)[(*Top_topol)].momenta[i]=
            get_mem(gtop_lnums[0]+1,sizeof(int *));
      }/*for(i=0;i<gtopologies[gtop_n_generic].n_momenta;i++)*/
      /* External momenta are just copied without any changings:*/
      for(i=1;!(i>ext_lines);i++){
         for(j=0;j<gtopologies[gtop_n_generic].n_momenta;j++)
            if(gtopologies[gtop_n_generic].ext_momenta[j] !=NULL)
               ((*Topologies)[(*Top_topol)].ext_momenta)[j][i]=
                  new_int(gtopologies[gtop_n_generic].ext_momenta[j][i]);
         }/*for(i=1;!(i>ext_lines);i++)*/
      /* Internal momenta are copied according to gtop_lnums:*/
      for(i=1;!(i>gtop_lnums[0]);i++){
         for(j=0;j<gtopologies[gtop_n_generic].n_momenta;j++){
           int k,s,*momentum;/* All this stuff we need to
                              * set the proper sign:( */
           /* Note, momenta are allocated according to red topology,
            * not usr! ( see "substituions map" in variabls.h)*/
            ((*Topologies)[(*Top_topol)].momenta)[j][
                                   ((*Topologies)[(*Top_topol)].l_subst)[i]
                                                    ]=momentum=
               new_int(gtopologies[gtop_n_generic].momenta[j][
                          (gtopologies[gtop_n_generic].l_subst)[gtop_lnums[i]]
                                                             ]);
           /* But, this is NOT the end of the story!
            * We must recognize the correct sign of the momenta!
            * The sign we have is the sign of momenta in gtopologies(red)
            * against gtopologies(usr).So, we need additional sign
            * ( see "substituions map" in variabls.h):
            * gtopologies[gtop_n_generic].l_dir[gtop_lnums[i]] --
            * converts the sign back to gtopologies(usr);
            * and ((*Topologies)[(*Top_topol)].l_dir[i]) converts it to the
            * Topologies(red):*/
            s=gtopologies[gtop_n_generic].l_dir[gtop_lnums[i]]*
              ((*Topologies)[(*Top_topol)].l_dir[i]);
            for(k=1;!(k>*momentum);k++)
               momentum[k]=s*momentum[k];
         }/*for(j=0;j<gtopologies[gtop_n_generic].n_momenta;j++)*/
      }/*for(i=1;!(i>gtop_lnums[0]);i++)*/
   }else{/* Read momenta from the scanner:*/
    int tmp_m[MAX_I_LINE],top_m,j,
    max_l=((*Topologies)[(*Top_topol)].topology)->i_n+1,
    max_e=((*Topologies)[(*Top_topol)].topology)->e_n+1;
    char ch[2];

      /* Alloc maximum memory first:*/
      (*Topologies)[(*Top_topol)].momenta=
         get_mem(MAX_MOMENTA_SET,sizeof(int **));
      (*Topologies)[(*Top_topol)].ext_momenta=
         get_mem(MAX_MOMENTA_SET,sizeof(int **));
        ch[1]=0;
        do{
           (*Topologies)[(*Top_topol)].momenta[(*Topologies)[(*Top_topol)].n_momenta]=
              get_mem(((*Topologies)[(*Top_topol)].topology)->i_n+1,sizeof(int *));
           for(j=1;!(j>((*Topologies)[(*Top_topol)].topology)->i_n);j++)
              ((*Topologies)[(*Top_topol)].momenta)[
                         (*Topologies)[(*Top_topol)].n_momenta][j]=NULL;
          /* Define are there external momenta: */
          sc_mark();
          if(*sc_get_token(str) == '['){/* Extra external momenta*/
             sc_release();
             (*Topologies)[(*Top_topol)].ext_momenta[(*Topologies)[(*Top_topol)].n_momenta]=
                 get_mem(((*Topologies)[(*Top_topol)].topology)->e_n+1,sizeof(int *));
              for(j=1;!(j>((*Topologies)[(*Top_topol)].topology)->e_n);j++)
                 ((*Topologies)[(*Top_topol)].ext_momenta)[
                            (*Topologies)[(*Top_topol)].n_momenta][j]=NULL;
             top_m=1;
             do{
                if(!(top_m<max_e))
                   terr((*Topologies),(*Top_topol),SUPERFLUOUSMOMENTUM,NULL);
                *tmp_m=0;
                do{
                   *ch=read_momentum_group(&i,str);
                   (*tmp_m)++;
                   if(!(*tmp_m<MAX_E_LINE))
                      terr((*Topologies),(*Top_topol),EXTDISAGREE,NULL);
                   tmp_m[*tmp_m]=i;
                }while(*ch=='\0');
                if((*ch==comma_char)||(*ch==']')){
                   (*Topologies)[(*Top_topol)].ext_momenta[(*Topologies)[
                                                   (*Top_topol)].n_momenta]
                                                [
                      max_e - (top_m++)
                                                 ]=new_int(tmp_m);
                   sc_get_token(str);
                }else
                   terr((*Topologies),(*Top_topol),UNEXPECTED,ch);
             }while(*ch!=']');
          }else{/*Just internal momenta*/
             sc_repeat();
          }
          top_m=1;
          if (max_l == 1){/* max_l = i_n+1 => NO internal lines AT ALL!*/
             *ch=*sc_get_token(str);/* must be ';' or ':' */
          }else{
             do{
                if(!(top_m<max_l))
                   terr((*Topologies),(*Top_topol),SUPERFLUOUSMOMENTUM,NULL);
                *tmp_m=0;
                do{
                   *ch=read_momentum_group(&i,str);
                   (*tmp_m)++;
                   if(!(*tmp_m<MAX_I_LINE))
                      terr((*Topologies),(*Top_topol),TOOMANYVECS,NULL);
                   tmp_m[*tmp_m]=i*(*Topologies)[(*Top_topol)].l_dir[top_m];
                }while(*ch==0);
                if((*ch==comma_char)||(*ch==';')||(*ch==':')){
                   (*Topologies)[(*Top_topol)].momenta[(*Topologies)
                                                [(*Top_topol)].n_momenta]
                                             [
                   ((*Topologies)[(*Top_topol)].l_subst)[top_m++]
                                              ]=new_int(tmp_m);
                   sc_get_token(str);
                }else
                   terr((*Topologies),(*Top_topol),UNEXPECTED,ch);
             }while(!((*ch==';')||(*ch==':')));
          }/*if (max_l == 1) ... else*/
          if(top_m!=max_l)
                terr((*Topologies),(*Top_topol),UNDEFMOM,NULL);
          if(++((*Topologies)[(*Top_topol)].n_momenta)>MAX_MOMENTA_SET)
                terr((*Topologies),(*Top_topol),TOOMANYMOMENTASETS,NULL);
        }while(*ch!=';');
        /* And now adjust allocated memory according exact values:*/
        if(
          (
            (*Topologies)[(*Top_topol)].momenta=realloc(
                (*Topologies)[(*Top_topol)].momenta,
                sizeof(int **)*(*Topologies)[(*Top_topol)].n_momenta
            )
          )==NULL
        )
         terr((*Topologies),(*Top_topol),NOTMEMORY,NULL);
        if(
          (
            (*Topologies)[(*Top_topol)].ext_momenta=realloc(
                (*Topologies)[(*Top_topol)].ext_momenta,
                sizeof(int **)*(*Topologies)[(*Top_topol)].n_momenta
            )
          )==NULL
        )
         terr((*Topologies),(*Top_topol),NOTMEMORY,NULL);
   }/*if(state == GETFROMGENERIC) ... else*/
   if (*Usertopologies_table==NULL)
      *Usertopologies_table=create_hash_table(Topology_hash_size,
                          hash_topology,topology_cmp,int_destructor);
   if(install((*Topologies)[(*Top_topol)].topology,
              newword(*Top_topol),
              *Usertopologies_table))
       halt(DOUBLETOPOLOGY,top2str((*Topologies)[(*Top_topol)].topology,str));
   if(state == GETFROMGENERIC){
      int l;
      /* Create linemarks according to gtop_lnums:*/
      l=((*Topologies)[(*Top_topol)].orig)->i_n;
      /* linemarks[0] == number of lines: */
      (*Topologies)[(*Top_topol)].linemarks=get_mem(l+1,sizeof(char*));
      *str=(char)l;str[1]='\0';
      *((*Topologies)[(*Top_topol)].linemarks)=new_str(str);
      for(i=1;!(i>l);i++){
         (*Topologies)[(*Top_topol)].linemarks[i]=new_str(long2str(str,gtop_lnums[i]));
      }/*for(i=1;!(i>l);i++)*/

      /* Remove this stuff -- this is a nonsense!
       * Let them be NULL:
      * Create vertexmarks according to gtop_vnums:*
      l=(*Topologies)[(*Top_topol)].max_vertex;
      * vertexmarks[0] == number of lines: *
      (*Topologies)[(*Top_topol)].vertexmarks=get_mem(l+1,sizeof(char*));
      *str=(char)l;str[1]='\0';
      *((*Topologies)[(*Top_topol)].vertexmarks)=new_str(str);
      for(i=1;!(i>l);i++){
         sprintf(str,"%d",gtop_vnums[i]);
         (*Topologies)[(*Top_topol)].vertexmarks[i]=new_str(str);
      }
      */

   }/*if(state == GETFROMGENERIC)*/
   (*Top_topol)++;
}/*read_topology*/

static int read_to_comma(char *str)/*Returns 1 if at the end was ','
                                  or 0 if ';'*/
{
  char tmp[MAX_STR_LEN];
  word len=2;
     *str=0;
     while(!((*sc_get_token(tmp)==comma_char)||(*tmp==';'))){
       if((len+=s_len(tmp))>MAX_STR_LEN) halt(TOOLONGSTRING,NULL);
       s_cat(str,str,tmp);
     }
     return((*tmp==comma_char)?1:0);
}/*read_to_comma*/

static int read_to_comma_or_bracket(char *str)/*Returns 1 if at the end was
                              ',' ; -1  if ';', 0 if ')'*/
{
  char tmp[MAX_STR_LEN];
  word len=2;
     *str=0;
     while(!((*sc_get_token(tmp)==comma_char)||(*tmp==';')||(*tmp==')'))){
       if((len+=s_len(tmp))>MAX_STR_LEN) halt(TOOLONGSTRING,NULL);
       s_cat(str,str,tmp);
     }
     if (*tmp==comma_char) return(1);
     if (*tmp==';') return(-1);
     return(0);
}/*read_to_comma_or_bracket*/

static void read_ext_part(char *tmp,char is_ingoing)
{
 int state;
 char ch;
 word *sec_id;
 char *frmid;
 int top_momenta,max_top_momenta,pos;
 struct ext_part_struct *ext;
   sc_mark();
   if (*sc_get_token(tmp)==';'){
      empty_external_item=1;
      sc_release();
      return;
   }else
      empty_external_item=0;

   sc_repeat();

   for(state=stINIT;state!=stEND;)switch(state){/*Begin finite automaton*/
      case stINIT:
         if(!(ext_lines<max_top_ext))
            if(
              (ext_particles=realloc(ext_particles,
                 (max_top_ext+=MAX_EXT_PART)*sizeof(struct ext_part_struct)))==
                 NULL
              )halt(NOTMEMORY,NULL);
         ext=&(ext_particles[ext_lines]);
         ext->id=NULL;
         ext->ind=NULL;
         ext->momentum=NULL;
         ext->is_ingoing=is_ingoing;
         top_momenta=1;
         max_top_momenta=0;
         state=stREADID;
         /*No break!*/
      case stREADID:
         if((sec_id=lookup(s_cat(tmp,"\1",sc_get_token(tmp)),main_id_table))
                                                                      ==NULL)
            halt(UNDEFINEDID,tmp+1);
            if(is_ingoing){
               ext->id=get_mem((s_len(tmp+1)+2),sizeof(char));
               m_let(tmp,ext->id);
            }else{
               ext->id=
                  get_mem(m_len(m_let(id[*(id[*sec_id].link)].id,tmp)),
                               sizeof(char));
               m_let(tmp,ext->id);
            }
            frmid=(id[(id[*sec_id].link)[1]].form_id)+1;/*To skip number of formid*/
            /*!!!*/if(frmid == NULL) halt("internal error",NULL);
         state=stREADSEPARATOR;
         /*No break!*/
      case stREADSEPARATOR:
         if(*sc_get_token(tmp)=='(')
            state=stREADIND;
         else if(*tmp==comma_char){
            (ext_lines)++;
            state=stINIT;
         }else if(*tmp==';'){
            (ext_lines)++;
            state=stEND;
         }else halt(UNEXPECTED,tmp);
         break;
      case stREADIND:
            sc_mark();
            if(*sc_get_token(tmp)==';'){
               /* Ok, no indices. But what about indices in form id?: */
               while(*frmid){
                  if(*frmid=='\2'){/*Index*/      /*???*/
                     halt(THEREAREUNDEFINEDINDICES,NULL);
                  }
                  if(*frmid==3){/*vector*/
                     frmid+=2;/*Skip particle id and number of vectors*/
                     while(*frmid++!='\n');/*Skip to the end of vectors*/
                  }
                  frmid++;
               }/*while(*frmid)*/
               sc_release();
            }else{
               char str[MAX_STR_LEN],buildind[MAX_STR_LEN];
               struct indices_struct *p;
               set_of_char endchars;
               set_of_char allgroups,usedgroups;
               int len=2;
               int group;
               unsigned char cgroup;

               set_sub(allgroups,allgroups,allgroups);/* Clear the set*/
               set_sub(usedgroups,usedgroups,usedgroups);/* Clear the set*/

               while(*frmid){
                  if(*frmid=='\2'){/*Index*/
                     if(*++frmid=='0')/*WE are interesting only in 1 particle*/
                        set_set(*++frmid,allgroups);
                  }
                  if(*frmid==3){/*vector*/
                     frmid+=2;/*Skip particle id and number of vectors*/
                     while(*frmid++!='\n');/*Skip to the end of vectors*/
                  }
                  frmid++;
               }/*while(*frmid)*/
               /* Now in 'allgroups' we have all groups
                  available for this particle*/
               *str=0;
               set_str2set(";:",endchars);
               set_set(comma_char, endchars);

               sc_repeat();
               buildind[0]='\0';
               do{
                  *tmp='\0';/* Clear new index*/
                  len+=3;/* ext-ind has such a structure:
                          * <N><g>\1<index>\0....<g>\1<index>\0
                          * So, each index requires 3 extra chars:<g>,\1,\0.*/
                  while (!set_in(*sc_get_token(str),endchars)){
                     if((len+=s_len(str))>MAX_STR_LEN)
                        halt(TOOLONGSTRING,NULL);
                     s_cat(tmp,tmp,str);
                  }/*while (!set_in(*sc_get_token(tmp),endchars))*/
                  /* Now in tmp we have the index*/
                  /* Determine the state:
                       *str==comma_char -- new index;
                       *str == ';' -- index belongs to the group 0;
                       *str == ':' -- have to read the group.
                   */
                   switch(state=*str){
                      case ';':
                         group=0;/* Default group is 0*/
                         state=0;/* This was the last index*/
                         break;
                      case ':':/* Looking for the group number:*/
                          if( (group=is_index_id(sc_get_token(str)))==-1)
                             halt(UNDEFINEDINDICESGROUP,str);
                          if(*sc_get_token(str)==comma_char){
                             state=1;/* Continue with the next index*/
                          }else if ( *str == ';' ){
                             state=0;/* This was the last index*/
                          }else/* ';' or comma_char expected*/
                             halt(UNEXPECTED,tmp);
                          break;
                      default:/*comma_char*/
                         /* New index is comming*/
                         state=1;/* Continue with the next index*/
                         group=0;/* Default group is 0*/
                         break;
                   }/*switch(state=*str)*/
                   cgroup=group+'0';/* Textual representation of the group*/
                   /*!! Restriction for only 1 index per group per particle: */
                   if(set_in(cgroup,usedgroups))
                      halt(ONLY1INDEX,NULL);
                   set_set(cgroup,usedgroups);/* Mark this group as used*/
                   if(!set_in(cgroup,allgroups))
                      halt(NOINEDINDICESGROUP,NULL);

                   if(  (indices==NULL)||(iNdex==NULL) )
                       halt(UNDEFINED,"indices");
                   /* Here the diagnostics is based on accounting groups
                    * starting from 1, not from 0 (but 0 is actual!).*/

                   if(  (iNdex[group]=indices[group]) ==NULL  ){
                      sprintf(tmp,"indices[%d]",group+1);/* See above*/
                      halt(UNDEFINED,tmp);
                   }
                   while(1){
                      if (iNdex[group]->next==NULL)halt(UNDEFINEDORUSED,tmp);
                         if(!s_scmp(iNdex[group]->next->id,tmp)){
                            /* Here we REMOVE this index since we will never
                             * use it again in "indices". It is just MOVED
                             * from indices to ext_particles:*/
                            p=iNdex[group]->next;
                            iNdex[group]->next=
                            iNdex[group]->next->next;
                            free(p->id);
                            free_mem(&p);
                            break;
                         }/*if(!s_scmp(iNdex->next->id,tmp))*/
                         iNdex[group]=iNdex[group]->next;
                   }/*while(1)*/
                   s_cat(tmp," \1",tmp);
                   *tmp=cgroup;
                   s_cat(tmp,"\1",tmp);
                   m_cat(buildind,buildind,tmp);
               }while(state);
               if(set_cmp(usedgroups,allgroups)==0){/* Allocate memory and store*/
                   ext->ind=get_mem(m_len(buildind),sizeof(char));
                   m_let(buildind,ext->ind);
               }else{/* Some indices are undefined!*/
                  halt(THEREAREUNDEFINEDINDICES,NULL);
               }
            }/*if(*sc_get_token(tmp)==';') ... else*/
         state=stREADVEC;
         /*No break!*/
      case stREADVEC:
         if(vectors_table==NULL)
            halt(UNDEFINED,"vectors");
         if(!(top_momenta<max_top_momenta))
            if((ext->momentum=realloc(ext->momentum,
                 sizeof(int)*(max_top_momenta+=DELTA_EXT_MOMENTA)))==NULL)
                    halt(NOTMEMORY,NULL);
         ch=read_momentum_group(&pos,tmp);
         (ext->momentum)[*(ext->momentum)=top_momenta]=pos;
         if(ch==0)
            top_momenta++;
         else if(ch==')'){
           sc_get_token(tmp);/*read ')'*/
           if(*sc_get_token(tmp)==comma_char){
              ext_lines++;
              state=stINIT;
           }else if(*tmp==';'){
              ext_lines++;
              state=stEND;
           }else halt(UNEXPECTED,tmp);
         }else halt(UNEXPECTED,tmp);
         break;
   }/*end finite automaton*/

}/*read_ext_part*/

static void calc_arc(double Ax,double Ay,double Bx,double By,
                            double Cx,double Cy,
                            double *Rad, double *Ox, double *Oy,
                            double *alpha_start,double *alpha_end)
/* Calculates arc through 3 points (A,B,C) so it starts at A and ends at C.
 * Output parameters: Rad -- radius, Ox,Oy -- center, alpha_start,
 * alpha_end -- start and and angles. If Rad>0.0, then
 * the angle is anti-clockwise; if Rad <MIN_POSSIBLE_COORDINATE,
 * the circle is degenerated, and (Ox,Oy) -- A coordinates,
 * (alpha_start,alpha_end) -- C coordinates;
 * if Rad<0.0, the angle is clockwise*/
{
  const double d_seps=0.00001;/* This is just a zero*/
  const double d_eps = D_EPS;/* Look at "comdef.h". Not too small, really?*/
  const double d_r2d = 57.29577951308232;/* 360/(2pi) */
  double D,
   /*Some frequently used expressions:*/
          Bx_m_Ax=Bx-Ax,By_m_Ay=By-Ay,
          Cx_m_Ax=Cx-Ax,Cy_m_Ay=Cy-Ay,
          Bx_p_Ax=Bx+Ax,By_p_Ay=By+Ay,
          Cx_p_Ax=Cx+Ax,Cy_p_Ay=Cy+Ay;

   /* Ox,Oy is the center of the circle.
    *  To find it, we solve equations:
    *     Ox(2Bx-2Ax)+Oy(2By-2Ay)=Bx^2+By^2-Ax^2-Ay^2;
    *     Ox(2Cx-2Bx)+Oy(2Cy-2Ay)=Cx^2+Cy^2-Ax^2-Ay^2;
    *  against Ox,Oy.
    * These eqs are comes from 3 possibilities of the radius
    * expression from the A,B,C,O coordinates.
    */

   D=4.0*(Bx_m_Ax*Cy_m_Ay-By_m_Ay*Cx_m_Ax);/* Determinant*/
   if(fabs(D)>d_eps){
      double tmp1=Bx_m_Ax*Bx_p_Ax+By_m_Ay*By_p_Ay;/*Bx^2+By^2-Ax^2-Ay^2*/
      double tmp2=Cx_m_Ax*Cx_p_Ax+Cy_m_Ay*Cy_p_Ay;/*Cx^2+Cy^2-Ax^2-Ay^2*/
      /* By Kramer's method:*/
      *Ox=2.0*(tmp1*Cy_m_Ay-tmp2*By_m_Ay)/D;
      *Oy=2.0*(tmp2*Bx_m_Ax-tmp1*Cx_m_Ax)/D;
      /* The center coordinates are ready*/
      /* This value, |CA|+|BA| must be COMPARABLE with the radius:*/
      tmp1=sqrt(Cy_m_Ay*Cy_m_Ay+Cx_m_Ax*Cx_m_Ax)+
           sqrt(By_m_Ay*By_m_Ay+Bx_m_Ax*Bx_m_Ax);
      /* Translate B coordinates to the center of the circle:*/
      Bx-=*Ox;
      By-=*Oy;
      *Rad=sqrt(Bx*Bx+By*By);/* The radius is ready*/
      if(
        (tmp1>d_seps)/* if not, a nonsense! ???*/
        &&
        (*Rad/tmp1/*Compare this with |CA|+|BA|*/
          <10.0)
        ){/* Ok. This is an arc. */
         double alpha_m;
         /* Translate coordinates system to the center of the circle:*/
         Ax-=*Ox;Cx-=*Ox;Ay-=*Oy;Cy-=*Oy;/* B already was translated earlier*/

         if(fabs(Ax)<d_eps){
            *alpha_start=(Ay>0.0)?(90.0):(-90.0);
         }else{
            *alpha_start=atan(Ay/Ax)*d_r2d;
            if(Ax<0.0)*alpha_start+=(180.0);
         }
         if(fabs(Bx)<d_eps){
            alpha_m=(By>0.0)?(90.0):(-90.0);
         }else{
            alpha_m=atan(By/Bx)*d_r2d;
            if(Bx<0.0)alpha_m+=(180.0);
         }
         if(fabs(Cx)<d_eps){
            *alpha_end=(Cy>0.0)?(90.0):(-90.0);
         }else{
            *alpha_end=atan(Cy/Cx)*d_r2d;
            if(Cx<0.0)*alpha_end+=(180.0);
         }

         if(*alpha_start > *alpha_end){
             /* -90 ---x--------------------x----- 270
                       ^alpha_end           ^alpha_start*/
            if ( (alpha_m<*alpha_start)&&(alpha_m>*alpha_end)){
                           /* -90 ----x////////////////////x---- 270
                                      ^alpha_end           ^alpha_start*/
               /* We use the Rad sign as mark that the angle is clockwice:*/
               *Rad = - *Rad;
            }/* else ok:     -90 ////x--------------------x////// 270
                                ^alpha_end           ^alpha_start*/
             /* the angle is ANTI-clockwice*/
         }else{ /* -90 ---x--------------------x----- 270
                          ^alpha_start         ^alpha_end*/
            if ( (alpha_m>*alpha_end)||(alpha_m<*alpha_start)){
                          /* -90 ////x--------------------x////// 270
                                     ^alpha_start           ^alpha_end*/
               /* We use the Rad sign as mark that the angle is clockwice:*/
               *Rad = - *Rad;
            }/* else ok: -90 ----x////////////////////x---- 270
                                 ^alpha_start         ^alpha_end*/
            /* the angle is ANTI-clockwice*/
         }/* if(*alpha_start > *alpha_end) ... else ... */
         return;
      }/* if(*Rad <MAX_POSSIBLE_COORDINATE) ended.*/
       /* So, if we are here, that means we have a stright line...*/
   }else{/* Too close points or all points at one line.*/
      if( (fabs(Cx_m_Ax)<d_eps)&&(fabs(Cy_m_Ay)<d_eps)){
            /* A coincides with C. We draw the circle
             * using A,B as diameter  */
         *Rad=sqrt(Bx_m_Ax*Bx_m_Ax +By_m_Ay*By_m_Ay)/2.0;/*Radius*/
         if (*Rad < d_eps){
            /* ALL points are practically coincide!
             * So mark it as a line:*/
            *Rad=MIN_POSSIBLE_COORDINATE-10.0;
           /* And store A and C coordinates with small shift:*/
           *Ox=Ax-d_eps; *Oy=Ay-d_eps;
           *alpha_start=Cx+d_eps; *alpha_end=Cy+d_eps;
           return;
         }/*if (*Rad < d_eps)*/
         *Ox=Bx_p_Ax/2.0;*Oy=By_p_Ay/2.0;/*The center*/

         /* We need the actual algle for tadpoles, too:
            the arrows must be placed properly.*/
         /* Now use Bx_m_Ax as Ax against O, By_m_Ay as Ay against O:*/
         Bx_m_Ax=Ax-*Ox;By_m_Ay=Ay-*Oy;/* I.e., translate to the center.*/
         /* And now determine the start angle:*/
         if(fabs(Bx_m_Ax)<d_eps){
            *alpha_start=(By_m_Ay>0.0)?(90.0):(-90.0);
         }else{
            *alpha_start=atan(By_m_Ay/Bx_m_Ax)*d_r2d;
            if(Bx_m_Ax<0.0)*alpha_start+=(180.0);
         }
         *alpha_end=*alpha_start+360.0;/* A tadpole...*/
         return;
      }
   }/* Here only one case is possible: stright line.*/

   /* all points at one line. We will connect A and C,
    * so just mark it as a line:*/
   *Rad=MIN_POSSIBLE_COORDINATE-10.0;
   /* And store A and C coordinates as:*/
   *Ox=Ax; *Oy=Ay;
   *alpha_start=Cx; *alpha_end=Cy;

}/*calc_arc*/

/* To use postscript routines for each arc we need :
 * ox,ox -- the center coordinates;
 * rad -- the radius;
 * start_angle -- start angle;
 * end_angle -- target angle.
 *
 * The following routine calculates these values for
 * each of the internal lines: */
static void calculate_topology_coordinates( aTOPOL *theTopology)
{
int i,j,toV,fromV;

double startPointX,middlePointX,endPointX,
       startPointY,middlePointY,endPointY;
const double d_eps = D_EPS;

    if( (theTopology->coordinates_ok==0)||
        ( theTopology->orig==NULL)  )/*Nothig to calculate:(*/
       return;

    /* Check external lines: they MAY appear to be of 0 length!*/
    /* Lines in topology stars from 1, not from 0:*/
    for(i=1; !(i>(theTopology->orig)->e_n); i++){

        fromV=(theTopology->orig)->e_n +
               theTopology->orig->e_line[i].from;/*external*/
        toV=theTopology->orig->e_line[i].to-1;/*internal*/

        /* Here we calculate directly startPoint-endPoint:*/
        startPointX=theTopology->iv[toV*2] - theTopology->ev[fromV*2];
        startPointY=theTopology->iv[toV*2+1] - theTopology->ev[fromV*2+1];

        if( (fabs(startPointX)<d_eps)&&(fabs(startPointY)<d_eps) ){
           /* These points are too close:(
            * Split them!:*/
           theTopology->iv[toV*2]+=d_eps;
           theTopology->iv[toV*2+1]+=d_eps;
           theTopology->ev[fromV*2]-=d_eps;
           theTopology->ev[fromV*2+1]-=d_eps;
        }/*if( (fabs(startPointX)<d_eps)&&(fabs(startPointY)<d_eps) )*/
    }/*for(i=1; !(i>(theTopology->topology)->i_n); i++)*/

    /*Internal lines:*/
    /* Lines in topology stars from 1, not from 0:*/
    for(i=1; !(i>(theTopology->orig)->i_n); i++){
       /* Determine start vertex coordinates:*/
       j= (  (theTopology->orig)->i_line[i].from-1 )*2;
       startPointX=theTopology->iv[j];
       startPointY=theTopology->iv[j+1];
       /* Determine end vertex coordinates:*/
       j= (  (theTopology->orig)->i_line[i].to-1 )*2;
       endPointX=theTopology->iv[j];
       endPointY=theTopology->iv[j+1];
       /* Determine middle point coordinates:*/
       j=(i-1)*2;
       middlePointX=theTopology->il[j];
       middlePointY=theTopology->il[j+1];

       /* Calculateing arc through 3 points (startPoint,middlePoint,
        * endPointY) starting at startPoint and ends at endPointY.
        * If Rad>0.0, then the angle is anti-clockwise;
        * if Rad<0.0, the angle is clockwis:*/
       j=i-1;
       calc_arc(startPointX,startPointY,
                middlePointX,middlePointY,
                endPointX,endPointY,
                theTopology->rad+j,
                theTopology->ox+j,
                theTopology->oy+j,
                theTopology->start_angle+j,
                theTopology->end_angle+j  );
    }/*for(i=1; !(i>(theTopology->topology)->i_n); i++)*/
}/*calculate_topology_coordinates*/

static void check_topology_coordinates( aTOPOL *theTopology)
{
int i,
    max_l=2*((theTopology->topology)->i_n),
    max_e=2*((theTopology->topology)->e_n),
    max_vertex=2*(theTopology->max_vertex);

    /* First, assume that something wrong*/
    theTopology->coordinates_ok=0;

    if(
       (theTopology->ev==NULL)||
       (theTopology->evl==NULL)||
       (theTopology->iv==NULL)||
       (theTopology->ivl==NULL)||
       (theTopology->el==NULL)||
       (theTopology->ell==NULL)
      )return;
    if(
       (max_l >0)&&
       (
          (theTopology->il==NULL)||
          (theTopology->ill==NULL)
       )
    )return;

    for(i=0;i<max_e;i++){
       if( (theTopology->ev)[i]<MIN_POSSIBLE_COORDINATE)
         return;
       if( (theTopology->evl)[i]<MIN_POSSIBLE_COORDINATE)
         return;
       if( (theTopology->el)[i]<MIN_POSSIBLE_COORDINATE)
         return;
       if( (theTopology->ell)[i]<MIN_POSSIBLE_COORDINATE)
         return;
    }
    for(i=0;i<max_l;i++){
       if( (theTopology->il)[i]<MIN_POSSIBLE_COORDINATE)
         return;
       if( (theTopology->ill)[i]<MIN_POSSIBLE_COORDINATE)
         return;
    }
    for(i=0;i<max_vertex;i++){
       if( (theTopology->iv)[i]<MIN_POSSIBLE_COORDINATE)
         return;
       if( (theTopology->ivl)[i]<MIN_POSSIBLE_COORDINATE)
         return;
    }
    /* Hm... All is ok! :*/
    theTopology->coordinates_ok=1;
    atleast_one_topology_has_coordinates = 1;
}/*check_topology_coordinates*/

/* This variable is set by get_topologies_from_generic().
 * We use this auxiliary static variable to pass the buffer to
 * read_topology() through reduce_lines() and make_topology():*/
static char *pass_str_to_make_topology=NULL;

static void make_topology(
   char **gname,/* Set of the base generic topology names*/
   int n_id,/*Number of entries in gname*/
   struct line_struct *ilines,
   struct line_struct *elines,/* Topology*/
   int *lines,/* Array of the length lines[0]+1: if 0, non-contracted,
                 if 1, contracted, lines[0] is the length of the array 'lines'.*/
   int *lnums,/* Array of the length lnums[0]+1: indices of lines corresponding
                to the original topology*/
   int *vnums/* Array of the length vnums[0]+1: indices of vertices corresponding
                to the original topology*/
)
{
int i,j;
static char tnam[MAX_STR_LEN],tmp[NUM_STR_LEN];
static tTOPOL topology, reduced_topology;

   /* Check if this topology already present:*/
   if(usertopologies_table != NULL){
      topology.i_n=lnums[0];
      topology.e_n=ext_lines;
      for(i=0;!(i>topology.i_n);i++)
         topology.i_line[i]=ilines[i];
      for(i=0;!(i>ext_lines);i++)
         topology.e_line[i]=elines[i];
      /* We must reduce topology before looking it up in the table.
       * Note, we do not interesting in l_ and v_ substitutions and
       * directions, so we set NULL instead of them:*/

      reduce_topology(0,sortinternalpartoftopology(&topology),
                              &reduced_topology,NULL,NULL,NULL);
      if (lookup(&reduced_topology, usertopologies_table)!=NULL)
         return;/* This topology is already set --
                 * by user, or from previous reduction.
                 */
   }/*if(usertopologies_table != NULL)*/

   /* Set static variables:*/
   gtop_gname=get_mem(n_id,sizeof(char*));/*Allocate memory for pointers*/
   /* Allocated memory for gtop_gname itself and for every enter
    * will NOT be free: it will just passed to the generated topology.
    */
   gtop_n_id=n_id;gtop_ilines=ilines;
   gtop_elines=elines;gtop_lines=lines;
   gtop_lnums=lnums;
   gtop_vnums=vnums;
   /* All identifiers are set as follows:
    * The head is just the base name gname[i] as
    * it is for the generic topology, and the tail is
    * _#_#_...#_, where # are the numbers of the reduced lines:*/
   for (j=0;j<n_id;j++){
      s_let(gname[j],tnam);/* Base name*/
      for(i=1;!(i>*lines);i++)/*For each reduced line we add #_:*/
        if(lines[i]){
           sprintf(tmp,"%d_",i);
           s_cat(tnam,tnam,tmp);
        }
      gtop_gname[j]=new_str(tnam);/* Store the result*/
   }/*for (j=0;i<n_id;j++)*/
   /*pass_str_to_make_topology is set by get_topologies_from_generic():*/
   read_topology(GETFROMGENERIC,pass_str_to_make_topology);
}/*make_topology*/

/* Recursive procedure. It reduces the line number "n", and call itself
 * for all lines with numbers greater then "n".
 * Before the recursive call this procedure call make_topology()
 * in order to set up the generated topology.
 * It is make_topology() that check if such a topology is already generated:*/
static int reduce_lines/* Return 0, if the line cannot be contrated, 1,
                        * if line was contracted, or -1, if it reproduces
                        *  the original topology without any changings (if n <1).
                        */
(
   char **gname,/* Set of the base generic topology names*/
   int n_id,/*Number of entries in gname*/
   struct line_struct *ilines,
   struct line_struct *elines,/* Topology*/
   int *plines,/* Array of the length lines[0]+1: if 0, non-contracted,
                 if 1, contracted, lines[0] is the length of the array 'lines'.*/
   int *plnums,/* Array of the length lnums[0]+1: indices of lines corresponding
                to the original topology*/
   int *pvnums,/* Array of the length vnums[0]+1: indices of lines corresponding
                to the original topology*/
   int n /*The index of the line to be contracted. If <=0, then it just
           creates the topology identical to the original one. */
)
{
int i,j;
char from,to;
struct line_struct *wilines,*welines;
int *wlines,*wlnums,*wvnums,*lines,*lnums,*vnums;
   /* n corresponds to the line numbers of the CURRENT topology,
      not to the INITIAL one!*/
   if (n<1){/*Somebody asks to reproduce the original topology
             * without any changings*/
      /* Perform topology generatig:*/
      make_topology(gname,n_id,ilines,elines,plines,plnums,pvnums);
      return(-1);/* And that's all.*/
   }
   if(ilines[n].to == ilines[n].from) return(0);/* Can't reduce a tadpole!*/
   if( (to=ilines[n].to)< (from=ilines[n].from) ){
      from=ilines[n].to;to=ilines[n].from;
   }
   /* max_order is GLOBAL variable changable from the configuration.
    * It means the maximal order of coupling (default is INIT_MAX_COUPLING):*/
   if (max_order){
      /* Calculating j -- the maximal order of vertex.
       * All lines except reduced, matches "to" or "from" vertices gives us
       * the sum of coupling :*/
      j=0;
      for(i=1;!(i>*plnums); i++){
         if(i == n)continue;

         if(
           (ilines[i].to == to)||
           (ilines[i].to == from)
         )j++;
         if(
           (ilines[i].from == to)||
           (ilines[i].from == from)
         )j++;
      }/*for(i=1;!(i>*plnums); i++)*/
      for(i=ext_lines;i>0;i--){
         if(
           (elines[i].to == to)||
           (elines[i].to == from)
         )j++;
      }/*for(i=ext_lines;i>0;i--)*/
      if(j>max_order)/* If we will reduce this line, then we
                          obtain too large degree of coupling:*/
         return(0);
   }/*if (max_order)*/
   /* wilines is working array of the internal lines
    * we will pass to make_topology():*/
   wilines = get_mem(*plnums,sizeof(struct line_struct));
   /* Reduce the line:*/
   for(j=0,i=1;!(i>*plnums); i++){
      if(i!=n){
        j++;
        if(  (wilines[j].from=ilines[i].from) == to  )
           wilines[j].from=from;
        else if( wilines[j].from > to)
            wilines[j].from--;
        if(  (wilines[j].to=ilines[i].to)==to  )
           wilines[j].to=from;
        else if( wilines[j].to > to)
                    wilines[j].to--;
      }
   }/*for(j=0,i=1;!(i>*lnums); i++)*/
   /* welines -- the working array of the external lines passed to
    * make_topology(). We need them since the vertices after
    * reduction may change:*/
   welines = get_mem(ext_lines+1,sizeof(struct line_struct));
   /*Possible changing the vertices numbers:*/
   for(i=1;!(i>ext_lines); i++){
     welines[i].from=elines[i].from;
     if(  (welines[i].to=elines[i].to)==to  )
        welines[i].to=from;
     else if( welines[i].to > to)
        welines[i].to--;
   }/*for(i=1;!(i>ext_lines); i++)*/

   /* lines and lnums are working arrays we change according to
    * reduction:*/
   lines=get_mem(*plines+1,sizeof(int));
   for(i=0;!(i>*plines);i++)
      lines[i]=plines[i];

   lines[plnums[n]]=1;

   *(lnums=get_mem(*plnums,sizeof(int)))=(*plnums)-1;
   for(i=1;i<n; i++)
      lnums[i]=plnums[i];
   for(i=n;i< *plnums; i++)
      lnums[i]=plnums[i+1];

   j= *(vnums=get_mem(*pvnums,sizeof(int)))=(*pvnums)-1;
   /* Here is the REAL reset of the information in vnums:*/
   j++;
   for(i=1;i<j; i++){
      if( pvnums[i] == to)
         vnums[i]=from;
      else if ( pvnums[i] > to)
         vnums[i]=pvnums[i]-1;
      else
         vnums[i]=pvnums[i];
   }/*for(i=1;i<j; i++)*/

   /* Perform topology generatig:*/
   make_topology(gname,n_id,wilines,welines,lines,lnums,vnums);

   /* We need new lnums, lines and vnums for every recursion:*/
   *(wlnums= get_mem(*lnums+1,sizeof(int)))=*lnums;
   *(wlines=get_mem(*lines+1,sizeof(int)))=*lines;
   *(wvnums= get_mem(*vnums+1,sizeof(int)))=*vnums;

   for(i=n;!(i>*lnums); i++){
       for(j=1;!(j>*lines);j++)
          wlines[j]=lines[j];
       for(j=0;!(j>*lnums);j++)
          wlnums[j]=lnums[j];
       for(j=0;!(j>*vnums);j++)
          wvnums[j]=vnums[j];
       reduce_lines(gname,n_id,wilines,welines,wlines,wlnums,wvnums,i);
   }/*for(i=n;!(i>*lnums); i++)*/
   /* That's all, free all allocated arrays:*/
   free_mem(&(wlines));
   free_mem(&(wlnums));
   free_mem(&(wvnums));
   free_mem(&(lnums));
   free_mem(&(vnums));
   free_mem(&(lines));
   free_mem(&(welines));
   free_mem(&(wilines));
   return(1);
}/*reduce_lines*/

static void get_topologies_from_generic(char *str)
{
int i;
int *plines=NULL;
int *plnums=NULL;
int *pvnums=NULL;
   /* Array of the length plines[0]+1: if 0, non-contracted,
             if 1, contracted, plines[0] is the length of the array 'plines':*/
   *(plines=get_mem( ((gtopologies[gtop_n_generic].orig)->i_n)+1,sizeof(int)))=
      (gtopologies[gtop_n_generic].orig)->i_n;
   /* Array of the length plnums[0]+1: indices of lines corresponding
                  to the original topology:*/
   *(plnums=get_mem( ((gtopologies[gtop_n_generic].orig)->i_n)+1,sizeof(int)))=
      (gtopologies[gtop_n_generic].orig)->i_n;
   /* Array of the length pvnums[0]+1: indices of vertices corresponding
                  to the original topology:*/
   *(pvnums=get_mem( (gtopologies[gtop_n_generic].max_vertex)+1,sizeof(int)))=
      gtopologies[gtop_n_generic].max_vertex;

   /* Initial values corresponds to the original non-contracted topology:*/
   for(i=1;!(i> (gtopologies[gtop_n_generic].orig)->i_n);i++){
      plines[i]=0;/* No contracted lines*/
      plnums[i]=i;/* Identical set*/
   }/*for(i=1;!(i> (gtopologies[gtop_n_generic].orig)->i_n);i++)*/
   for(i=1;!(i> gtopologies[gtop_n_generic].max_vertex);i++){
      pvnums[i]=i;/* Identical set*/
   }/*for(i=1;!(i> gtopologies[gtop_n_generic].max_vertex);i++)*/

   /* We use this auxiliary static variable to pass the buffer to
    * read_topology() through reduce_lines() and make_topology():*/
   pass_str_to_make_topology=str;
   /* For each line:*/
   for(i=0;!(i> (gtopologies[gtop_n_generic].orig)->i_n);i++){
      /* Call this recursive procedure:*/
      reduce_lines(
         gtopologies[gtop_n_generic].id,/* Set of the base generic topology names*/
         gtopologies[gtop_n_generic].n_id,/*Number of entries in gname*/
         (gtopologies[gtop_n_generic].orig)->i_line,
         (gtopologies[gtop_n_generic].orig)->e_line,/* Topology*/
         plines,
         plnums,
         pvnums,
         i/*The index of the line to be contracted*/
      );
   }/*for(i=1;!(i> (gtopologies[gtop_n_generic].orig)->i_n);i++)*/
   free_mem(&plnums);
   free_mem(&pvnums);
   free_mem(&plines);
}/*get_topologies_from_generic*/

static void read_topology_coordinates( aTOPOL *theTopology ,char *str)
{
double *carray;
int state,i,last,
    max_l=2*((theTopology->topology)->i_n),
    max_e=2*((theTopology->topology)->e_n),
    max_vertex=2*(theTopology->max_vertex);
    /* First, we can need topologies to be generated from generic:*/
    if(top_gtopol != 0 ){/* There are at least one generic topology*/
       for(gtop_n_generic=0;gtop_n_generic<top_gtopol; gtop_n_generic++){
          get_topologies_from_generic(str);/* static*/
       }/*for(gtop_n_generic=0;gtop_n_generic<top_gtopol; gtop_n_generic++)*/
       clear_gtopologies_tables();
    }/*(top_gtopol != 0 )*/

    state=stINIT;
    while(state!=stEND){
       /*****************************************************************
        * The protocol is the following:                                *
        * coordinates <topologyname>=ev x,y,x,y ... :evl x,y,x,y ....   *
        * :iv x,y,x,y ... :ivl x,y,x,y .... :el x,y,x,y ...             *
        * :ell x,y,x,y.... :il x,y,x,y ... :ill x,y,x,y ....;           *
        * where                                                         *
        *      ev  -- external vertices,                                *
        *      evl -- external vertices labels,                         *
        *      iv  -- internal vertices,                                *
        *      ivl -- internal vertices labels,                         *
        *      el  -- external lines,                                   *
        *      ell -- external lines labels,                            *
        *      il  -- internal lines,                                   *
        *      ill -- internal lines labels,                            *
        *****************************************************************/
          if( s_scmp(sc_get_token(str),"ev")==0 ){
             last=max_e;
             carray=theTopology->ev;
          }else if( s_scmp(str,"evl")==0 ){
             last=max_e;
             carray=theTopology->evl;
          }else if( s_scmp(str,"iv")==0 ){
             last=max_vertex;
             carray=theTopology->iv;
          }else if( s_scmp(str,"ivl")==0 ){
             last=max_vertex;
             carray=theTopology->ivl;
          }else if( s_scmp(str,"el")==0 ){
             last=max_e;
             carray=theTopology->el;
          }else if( s_scmp(str,"ell")==0 ){
             last=max_e;
             carray=theTopology->ell;
          }else if( s_scmp(str,"il")==0 ){
             last=max_l;
             carray=theTopology->il;
          }else if( s_scmp(str,"ill")==0 ){
             last=max_l;
             carray=theTopology->ill;
          }else{
             halt(COORDTYPEEXPECTED,str);
          }
          if (last == 0)/*In all cases, we have to read the token.*/
             sc_get_token(str);/* Here we can be only at i_n == 0*/
          else for(i=0; i<last;i++){
             if(*sc_get_token(str)=='-')
                s_cat(str,"-",sc_get_token(str));
             else if(*str == '+')
                sc_get_token(str);
             else if(   (*str == ':')||(*str == ';') )
                break;
             if(sscanf(str,"%lf",carray+i)!=1)
                halt(CANNOTCONVERTTONUMBER,str);
             if(*sc_get_token(str)!=','){
                if(i!=(last-1) )
                   halt(COMMAEXPECTED,str);
                if( !((*str == ':')||(*str == ';')) )
                   halt(COLEXPECTED,str);
             }/*if(*sc_get_token(str)!=',')*/
          }/*else for(i=0; i<last;i++)*/
          if( *str == ';')
             state=stEND;
          else if(*str != ':')
             halt(COLEXPECTED,str);
    }/*while(state!=stEND;)*/
}/*read_topology_coordinates*/

void read_config_file_before_truns(void)
{
 int state,indlen;
 long num=0;
 set_of_char valid_esc;
 char esc_line[2];
 char tmp[MAX_STR_LEN], *ptr,mem_ext;
 static char *index_default_id=INDEX_ID;

    /*All ext particles < g_last_ingoing are ingoing:*/
    g_last_ingoing=0;
    set_str2set(VALIDID,valid_id);
    *esc_line=ESC_CHAR;
    esc_line[1]=0;
    set_str2set(VALID_ESC_CHAR,valid_esc);
    current_particles=get_mem(MAX_LINES_IN_VERTEX,sizeof(char*));
    for(state=0;state<MAX_LINES_IN_VERTEX;state++)
       current_particles[state]=get_mem(MAX_STR_LEN,sizeof(char));
    /* This table will be used to keep a contron on the uniqueness of id's:*/
    id_replace_table=create_hash_table(ID_REPLACE_TABLE_SIZE,
                                              str_hash,str_cmp,empty_destructor);

    install(index_default_id,index_default_id,id_replace_table);
    install(momentum_id,momentum_id,id_replace_table);
    install(vl_counter_id,vl_counter_id,id_replace_table);
    install(lm_counter_id,lm_counter_id,id_replace_table);
    install(f_counter_id,f_counter_id,id_replace_table);
    install(fflow_counter_id,fflow_counter_id,id_replace_table);
    install(from_counter_id,from_counter_id,id_replace_table);
    install(to_counter_id,to_counter_id,id_replace_table);
    for(state=stINIT; state!=stEND;)switch(state){/*Begin finite automaton*/
       case stINIT:
          if(*sc_get_token(tmp)=='[') state=stBEGINID;
          else if(!s_scmp(tmp,"topology")) state=stTOPOLOGY;
          else if(!s_scmp(tmp,"remarks"))state=stREMARKS;
          else if(!s_scmp(tmp,"coordinates")) state=stCOORDINATES;
          else if(!s_scmp(tmp,"export")) state=stPARAMETER;
          else if(!s_scmp(tmp,"SET")) state=stSET;
          else if(!s_scmp(tmp,"generictopology")) state=stGENERICTOPOLOGY;
          else if(!s_scmp(tmp,"linemarks")) state=stLINEMARKS;
          else if(!s_scmp(tmp,"vertexmarks")) state=stVERTEXMARKS;
          else if(!s_scmp(tmp,"number")) state=stNUMBER;
          else if(!s_scmp(tmp,"token")) state=stTOKEN;
          else if(!s_scmp(tmp,"select")) state=stSELECT;
          else if(!s_scmp(tmp,"esc")) state=stESC;
          else if(!s_scmp(tmp,"comment")) state=stCOMMENT;
          else if(!s_scmp(tmp,"comma")) state=stCHCOMMA;
          else if(!s_scmp(tmp,"index")) state=stINDEX;
          else if(!s_scmp(tmp,"lvmark")) state=stLINEVERTMARK_ID;
          else if(!s_scmp(tmp,"momentum")) state=stMOMENTUM;
          else if(!s_scmp(tmp,"input")) state=stINPUT;
          else if(!s_scmp(tmp,"log")) state=stLOG;
          else if(!s_scmp(tmp,"output")) state=stOUTFILE;
          else if(!s_scmp(tmp,"system")) state=stSYSTPATH;
          else if(!s_scmp(tmp,"functions")) state=stFUNCTIONS;
          else if(!s_scmp(tmp,"commuting")) state=stCOMMUTING;
          else if(!s_scmp(tmp,"indices")) state=stINDICES;
          else if(!s_scmp(tmp,"vectors")) state=stVECTORS;
          else if(!s_scmp(tmp,"ingoing")) state=stINGOING;
          else if(!s_scmp(tmp,"outgoing")) state=stOUTGOING;
          else if(!s_scmp(tmp,"fermion")) state=stFERMION;
          else if(!s_scmp(tmp,esc_line)) state=stSPECMODE;
          else if(!s_scmp(tmp,"counter")) state=stCOUNTER;
          else if(!s_scmp(tmp,"from")) state=stFROMVERTEX;
          else if(!s_scmp(tmp,"to")) state=stTOVERTEX;
          else if(!s_scmp(tmp,"messages")) state=stMESSAGES;
          else if(!s_scmp(tmp,"tadpoles")) state=stTADPOLES;
          else if(!s_scmp(tmp,"forced")) state=stFORCED;
          else if(!s_scmp(tmp,"extra")) state=stEXTRA;
          else if(!s_scmp(tmp,"only")) state=stONLYINTERPRET;
          else if(!s_scmp(tmp,"debug")) state=stDEBUG;
          else if(!s_scmp(tmp,"outlines")) state=stOUTLINES;
          else if(!s_scmp(tmp,"marks"))state=stMAXMARKLENGTH;
          else if(!s_scmp(tmp,"flip"))state=stFLIP;
          else if(!s_scmp(tmp,"external"))state=stEXTERNAL;
          else if(!s_scmp(tmp,"loop"))state=stLOOPMOMENTA;
          else if(!s_scmp(tmp,"zero"))state=stZEROMOMENTUM;
          else if(!s_scmp(tmp,"ignore"))state=stIGNOREMOMENTA;
          else if(!s_scmp(tmp,"bridge"))state=stBRIDGESUBST;
          else if(!s_scmp(tmp,"chord"))state=stCHORDSUBST;
          else if(!s_scmp(tmp,"sortlinesbytype"))state=stSORTBYTYPE;
          else if(!s_scmp(tmp,"trace"))state=stTRACE;
          else halt(UNEXPECTED, tmp);
          break;
       case stREMARKS:
       case stCOORDINATES:
       case stLINEMARKS:
       case stVERTEXMARKS:
          if(top_gtopol != 0 ){/* There are at least one generic topology*/
             for(gtop_n_generic=0;gtop_n_generic<top_gtopol; gtop_n_generic++){
                get_topologies_from_generic(tmp);/* static*/
             }/*for(gtop_n_generic=0;gtop_n_generic<top_gtopol; gtop_n_generic++)*/
             clear_gtopologies_tables();
          }/*(top_gtopol != 0 )*/

          /* Coordinates and linemarks must belong to the topology:*/
          if (topology_id_table==NULL)
             halt(NOTOPOLOGIESYET,NULL);
          {/*block begin*/
             int *n,i,l;
             if((n=lookup(sc_get_token(tmp),topology_id_table))==NULL)
                halt(TOPOLOGYISUNDEFINED,tmp);
             if(*sc_get_token(tmp)!='=')
                halt(EQUALEXP,tmp);
             switch(state){
                case stREMARKS:
                   switch ( readTopolRemarksFromScanner
                   (
                      &(topologies[*n].top_remarks),/* ptr to the top of allocate remarks array*/
                      &(topologies[*n].remarks),/*ptr to the  remarks array*/
                      g_uniqueRemarksName,/*0 if new "name" may rewrite existing one*/
                      /*Function char *getToken(void *) must return the token from the scanner:*/
                      /*ATTENTION! sc_get_token is a variable, not a function!
                        NO &sc_get_token, just sc_get_token!!:*/
                      (GET_TOKEN_FUNC *) sc_get_token,
                      (void *) tmp/* the argument for the function getToken*/
                   )
                   ){
                      /*Error codes returned by readTopolRemarksFromScanner:*/
                      /*Double defined name:*/
                      case REM_DOUBLEDEF:
                         halt(DOUBLEDEFREMNAME,NULL);
                      /*Empty name is not allowed:*/
                      case REM_EMPTYNAME:
                         halt(EMPTYREMNAME,NULL);
                      /*Not enought memory:*/
                      case REM_NOTMEMORY:
                         halt(NOTMEMORY,NULL);
                      /*Unexpected end of file:*/
                      case REM_U_EOF:/*Never occur with this getToken function!*/
                         halt(UNEXPECTEDEOF,NULL);
                      /*Unexpected '=':*/
                      case REM_UNEXPECTED_EQ:
                         halt(UNEXPECTED,"=");
                      }/*switch ( readTopolRemarksFromScanner ...*/
                      break;
                case stCOORDINATES:
                   read_topology_coordinates(topologies+ *n, tmp);
                   break;
                case stLINEMARKS:
                   /* Get number of the internal lines:*/
                   if( (l=(topologies[*n].topology)->i_n) == 0){/*NO internal lines!*/
                      /*Here we allow empty linemarks for pure vertex:*/
                      if(*sc_get_token(tmp)!=';')
                         halt(SEMICOLEXP,tmp);
                      break;
                   }/*if( (l=(topologies[*n].topology)->i_n) == 0)*/

                   /* linemarks[0] == number of lines: */

                   if(topologies[*n].linemarks!=NULL){
                   /* Already exist... Clear them!*/
                      for(i=0; !(i>l);i++)
                         free_mem( &(topologies[*n].linemarks[i]));
                      free_mem( &(topologies[*n].linemarks));
                   }/*if(topologies[*n].linemarks!=NULL)*/
                   topologies[*n].linemarks=get_mem(l+1,sizeof(char*));
                   *tmp=(char)l;tmp[1]='\0';
                   *(topologies[*n].linemarks)=new_str(tmp);
                   for(i=1;!(i>l);i++){
                      /* Read line marks:*/
                      if(read_to_comma(tmp)==0){
                         /* All line marks are read... Really all?:*/
                         if(i !=l )halt(UNSUFFICIENTLINEMARKS,NULL);
                      }
                      /* And store them into the topology:*/
                      topologies[*n].linemarks[i]=new_str(tmp);
                   }/*for(i=1;!(i>l);i++)*/
                   break;
                case stVERTEXMARKS:
                   /* Get number of vertices:*/
                   l=topologies[*n].max_vertex;
                   /* vertexmarks[0] == number of vertices: */

                   if(topologies[*n].vertexmarks!=NULL){
                   /* Already exist... Clear them!*/
                      for(i=0; !(i>l);i++)
                         free_mem( &(topologies[*n].vertexmarks[i]));
                      free_mem( &(topologies[*n].vertexmarks));
                   }/*if(topologies[*n].vertexmarks!=NULL)*/
                   topologies[*n].vertexmarks=get_mem(l+1,sizeof(char*));
                   *tmp=(char)l;tmp[1]='\0';
                   *(topologies[*n].vertexmarks)=new_str(tmp);
                   for(i=1;!(i>l);i++){
                      /* Read vertex marks:*/
                      if(read_to_comma(tmp)==0){
                         /* All vertex marks are read... Really all?:*/
                         if(i !=l )halt(UNSUFFICIENTVERTEXMARKS,NULL);
                      }
                      /* And store them into the topology:*/
                      topologies[*n].vertexmarks[i]=new_str(tmp);
                   }/*for(i=1;!(i>l);i++)*/
                   break;
             }/*switch(state)*/
          }/*block end*/
          state=stINIT;
          break;
       case stOUTLINES:
          if (*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          sc_get_token(tmp);/* Must be the number...*/
          state=stINIT;
          break;
       case stTRACE:
          if(!s_scmp(sc_get_token(tmp),"off"))
             g_trace_on_really=g_trace_on=0;
          else if(!s_scmp(tmp,"on"))
             g_trace_on_really=g_trace_on=1;
          else halt(UNEXPECTED, tmp);
          state=stINIT;
          break;
       case stDEBUG:
          if(
             (!s_scmp(sc_get_token(tmp),"off"))||
             (!s_scmp(tmp,"0"))
            ){
             unset_bit(&isdebug,bitDEBUG);
             g_debug_offset=0;
          }else if( 
                    (!s_scmp(tmp,"on"))||
                    (!s_scmp(tmp,"1"))
                  ){
                    set_bit(&isdebug,bitDEBUG);
                    g_debug_offset=0;
          }else if(!s_scmp(tmp,"2")){
             set_bit(&isdebug,bitDEBUG);
#ifndef NO_DEBUGGER
                     /* line/filename info is stored into the beginning of the 
                        polish line. To store debug info, g_debug_offset = 7
                        (4 for encoded line number +1, 2 for the colomns number (segment+1
                        and offset+1 ), 1 for the file number +1)
		      */
             g_debug_offset=7;
#endif
          }else halt(UNEXPECTED, tmp);
          state=stINIT;
          break;
       case stONLYINTERPRET:
          if(s_scmp(sc_get_token(tmp),"interpret"))
             halt(INTERPRETEXPECTED, tmp);
          set_bit(&mode,bitONLYINTERPRET);
          if(*programname)include(programname);
          do{
             while(*sc_get_token(tmp)!=*esc_line);
             if(!s_scmp(sc_get_token(tmp),"begin")) state=stBEGINTRUNSLATE;
             else if (!s_scmp(tmp,"include")){
               include(get_inkl_name(tmp));
               state=stREPEAT;
             }else if(!s_scmp(tmp,"openlanguage")){
               include(get_inkl_name(tmp));
               state=stEND;
             }else halt(UNEXPECTED, tmp);
          }while(state==stREPEAT);
          break;
       case stSET:{char *name,*val;
             name=new_str(sc_get_token(tmp));
             if (*sc_get_token(tmp)!='=')
                halt(EQUALEXP, tmp);
             if(*sc_get_token(tmp)=='"')
                 val=new_str(read_file_name(tmp));
             else
                 val=new_str(tmp);
             if (set_table==NULL)set_table=create_hash_table(
                           set_hash_size,str_hash,str_cmp,c_destructor);
             install(name,val,set_table);
          }
          state=stINIT;
          break;
       case stPARAMETER:
           {char nam[MAX_STR_LEN];
            sc_get_token(nam);
            if(*sc_get_token(tmp)!='=')
               halt(EQUALEXP, tmp);
            if(*sc_get_token(tmp)=='"')
                 set_export_var(nam,read_file_name(tmp));
            else
                 set_export_var(nam,tmp);
            }
          state=stINIT;
          break;
       case stFORCED:
          if(s_scmp(sc_get_token(tmp),"execute"))
             halt(TRUNSEXPECTED, tmp);
          set_bit(&mode,bitFORCEDTRUNSLATION);
          state=stINIT;
          break;
       case stEXTRA:
          if(s_scmp(sc_get_token(tmp),"call"))
             halt(CALLEXPECTED, tmp);
          set_bit(&mode,bitEND);
          state=stINIT;
          break;
       case stMESSAGES:
          if(!s_scmp(sc_get_token(tmp),"enable"))
              message_enable=1;
          else if(!s_scmp(tmp,"disable")){
              message_enable=0;
              message("Messages disabled.",NULL);
          }else
              halt(UNEXPECTED, tmp);
          state=stINIT;
          break;
       case stTADPOLES:
          if(!s_scmp(sc_get_token(tmp),"enable"))
              skiptadpoles=0;
          else if(!s_scmp(tmp,"disable"))
              skiptadpoles=1;
          else
              halt(UNEXPECTED, tmp);
          state=stINIT;
          break;

       case stFROMVERTEX:
       case stTOVERTEX:
          if(s_scmp(sc_get_token(tmp),"vertex"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          if(!set_in(*sc_get_token(tmp),valid_id))
             halt(INVALIDBEGINOFID,tmp);
          if (!(s_len(tmp)<MAX_INDEXID_LEN))
             halt(TOOLONGID,tmp);
          if(state==stFROMVERTEX){
             uninstall(from_counter_id,id_replace_table);
             s_let(tmp,from_counter_id);
             if( install(from_counter_id,from_counter_id,id_replace_table) )
                halt(IDALREADYUSED,from_counter_id);
          }else{
             uninstall(to_counter_id,id_replace_table);
             s_let(tmp,to_counter_id);
             if( install(to_counter_id,to_counter_id,id_replace_table) )
                halt(IDALREADYUSED,to_counter_id);
          }
          state=stINIT;
          break;
       case stCOUNTER:
          if(!s_scmp(sc_get_token(tmp),"vertex")){
             state=stVL_NUMBER_RESET;
             if(s_scmp(sc_get_token(tmp),"or"))
                  halt(UNEXPECTED, tmp);
          }else if(!s_scmp(tmp,"fermion"))
             state=stF_COUNTER_RESET;
          else
             halt(UNEXPECTED, tmp);
          if(
            (s_scmp(sc_get_token(tmp),"line"))||
            (*sc_get_token(tmp)!='=')
            )
              halt(UNEXPECTED, tmp);
          if(!set_in(*sc_get_token(tmp),valid_id))
             halt(INVALIDBEGINOFID,tmp);
          if (!(s_len(tmp)<MAX_INDEXID_LEN))
             halt(TOOLONGID,tmp);

          if(state==stVL_NUMBER_RESET){
             uninstall(vl_counter_id,id_replace_table);
             s_let(tmp,vl_counter_id);
             if( install(vl_counter_id,vl_counter_id,id_replace_table) )
                halt(IDALREADYUSED,vl_counter_id);
          }else{
             uninstall(f_counter_id,id_replace_table);
             s_let(tmp,f_counter_id);
             if( install(f_counter_id,f_counter_id,id_replace_table) )
                halt(IDALREADYUSED,f_counter_id);

          }
          state=stINIT;
          break;
       case stBEGINID:
          for(number_of_current_particle=0;
                number_of_current_particle<MAX_LINES_IN_VERTEX;
                number_of_current_particle++){
            *(current_particles[number_of_current_particle])=0;
          }
          number_of_current_particle=0;
          read_model(tmp);
          state=stINIT;
          break;
       case stESC:
          if(s_scmp(sc_get_token(tmp),"character"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          if(!set_in(*sc_get_token(tmp),valid_esc))
             halt(INVALDESCCHAR,tmp);
          *esc_line=esc_char=q_char=*tmp;
          state=stINIT;
          break;
       case stTOKEN:
          {/*block*/
             char *nam= new_str(sc_get_token(tmp));
             char *val;
             if(*sc_get_token(tmp)!='=')
                halt(EQUALEXP, tmp);
             if(*sc_get_token(tmp)=='"')
                 val=new_str(read_file_name(tmp));
             else
                 val=new_str(tmp);
             if (g_ttTokens_table==NULL)g_ttTokens_table=create_hash_table_with_copy(
                           g_defaultTokenDictSize,
                           str_hash,
                           str_cmp,
                           c_destructor,
                           (CPY *)NEWSTR,
                           (CPY *)NEWSTR);
             install(nam,val,g_ttTokens_table);
          }/*block*/
          state=stINIT;
          break;
       case stCOMMENT:
          if(s_scmp(sc_get_token(tmp),"character"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          new_comment(cnf_comment=*sc_get_token(tmp));
          state=stINIT;
          break;
       case stCHCOMMA:
          if(s_scmp(sc_get_token(tmp),"character"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          comma_char=*sc_get_token(tmp);
          state=stINIT;
          break;
       case stOUTFILE:
          if(s_scmp(sc_get_token(tmp),"file"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          if(*sc_get_token(tmp)=='"')
              read_file_name(tmp);
          if(!s_scmp(tmp,"null")){
               outfile=NULL;
            }else if(*tmp)
               outfile=open_file(tmp,"w+");
            else
               outfile=stdout;
          state=stINIT;
          break;
       case stINDEX:
          if(index_id!=NULL){/* Hm.. It was installed already*/
               int i;
                for(i=0; i<numberOfIndicesGroups;i++)if (index_id[i]!=NULL){
                   uninstall(index_id[i],id_replace_table);
                   free(index_id[i]);
                }
                free_mem(&index_id);
          }/*if(index_id!=NULL)*/
          /* No problem to uninstall it more then once since
           * we use empty destructor:*/
          uninstall(index_default_id,id_replace_table);

          if(*sc_get_token(tmp)==':'){
            numberOfIndicesGroups=-1;
            numberOfIndicesGroups=str2long(sc_get_token(tmp));
            if(    (numberOfIndicesGroups<1)||
                   (numberOfIndicesGroups>126)   )
               halt(INVALIDNUMBER,tmp);
            sc_get_token(tmp);/* Must be '='*/
          }else{
             numberOfIndicesGroups=1;
          }
          if(*tmp!='=')
             halt(EQUALEXP, tmp);
          {/*block begin*/
          int i;

          allocate_indices_structures();/*utils.c*/
          for(i=0; i<numberOfIndicesGroups;i++){
             if(i>0){
                if(*sc_get_token(tmp)!=comma_char)
                   halt(COMMAEXPECTED,tmp);
             }
             if(!set_in(*sc_get_token(tmp),valid_id))
                halt(INVALIDBEGINOFID,tmp);
             index_id[i]=new_str(tmp);
             if( install(index_id[i],index_id[i],id_replace_table) )
                halt(IDALREADYUSED,index_id[i]);
          }/*for(i=0; i<numberOfIndicesGroups;i++)*/
          }/*block end*/
          state=stINIT;
          break;
       case stLINEVERTMARK_ID:
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          if(!set_in(*sc_get_token(tmp),valid_id))
             halt(INVALIDBEGINOFID,tmp);
          if (!(s_len(tmp)<MAX_INDEXID_LEN))
             halt(TOOLONGID,tmp);
          uninstall(lm_counter_id,id_replace_table);
          s_let(tmp,lm_counter_id);
          if( install(lm_counter_id,lm_counter_id,id_replace_table) )
             halt(IDALREADYUSED,lm_counter_id);
          state=stINIT;
          break;
       case stMOMENTUM:
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          if(!set_in(*sc_get_token(tmp),valid_id))
             halt(INVALIDBEGINOFID,tmp);
          if (!(s_len(tmp)<MAX_MOMENTUM_LEN))
             halt(TOOLONGID,tmp);
          uninstall(momentum_id,id_replace_table);
          s_let(tmp,momentum_id);
          uninstall(momentum_id,id_replace_table);
          if( install(momentum_id,momentum_id,id_replace_table) )
             halt(IDALREADYUSED,momentum_id);
          state=stINIT;
          break;
       case stINPUT:
          if(s_scmp(sc_get_token(tmp),"file"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          free_mem(&input_name);
          if(*sc_get_token(tmp)=='"')
              input_name=new_str(read_file_name(tmp));
          else
              input_name=new_str(tmp);
          state=stINIT;
          break;
       case stLOG:
          if(s_scmp(sc_get_token(tmp),"file"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          free_mem(&log_name);
          if(*sc_get_token(tmp)=='"')
              log_name=new_str(read_file_name(tmp));
          else
              log_name=new_str(tmp);
          close_file(&log_file);
          log_file=open_file(log_name,"w+");
          message(OPENLOG,log_name);
          message(FULLCMDLINE,NULL);
          message(full_command_line,NULL);
          message("",NULL);
          state=stINIT;
          break;
       case stSYSTPATH:
          if(s_scmp(sc_get_token(tmp),"path"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          free_mem(&system_path);
          if(*sc_get_token(tmp)=='"')
              system_path=new_str(read_file_name(tmp));
          else
              system_path=new_str(tmp);
          system_path=correct_trailing_slash(system_path);
          state=stINIT;
          break;

       case stMAXMARKLENGTH:
          if(s_scmp(sc_get_token(tmp),"length"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          /* If main_id_table!=NULL, then there exists some form_id with
           * allocated space for ID's:*/
          if(main_id_table!=NULL)
             halt(CANNOTRESETTABLE,NULL);
          if ((sscanf(sc_get_token(tmp),"%d",&max_marks_length)!=1)||
              (!(max_marks_length>0)))
                halt(INVALIDNUMBER,tmp);
          if(++max_marks_length > MAX_STR_LEN ){
             halt(MAXIMALALLOWEDNUMBER,long2str(tmp,MAX_STR_LEN-1));
          }
          free(p15);
          p15=get_mem(max_marks_length,sizeof(char*));
          for(num=max_marks_length-2;!(num<0);num--)p15[num]=15;
          p15[max_marks_length-1]='\0';

          state=stINIT;
          break;
       case stFLIP:
          if(!s_scmp(sc_get_token(tmp),"momenta"))
             state=stFLIPMOMENTA;
          else if(!s_scmp(tmp,"majorana"))
             state=stMAJORANA;
          else
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          break;
       case stIGNOREMOMENTA:
          if(s_scmp(sc_get_token(tmp),"table"))
             halt(UNEXPECTED, tmp);
          if(s_scmp(sc_get_token(tmp),"momenta"))
             halt(UNEXPECTED, tmp);
          if(!s_scmp(sc_get_token(tmp),"enable"))
             g_ignoreMomenta=1;
          else if(!s_scmp(tmp,"disable"))
             g_ignoreMomenta=0;
          else
             halt(UNEXPECTED, tmp);
          state=stINIT;
          break;
       case stFLIPMOMENTA:
          if(!s_scmp(sc_get_token(tmp),"enable"))
             g_flip_momenta_on_lsubst=1;
          else if(!s_scmp(tmp,"disable"))
             g_flip_momenta_on_lsubst=0;
          else
             halt(UNEXPECTED, tmp);
          state=stINIT;
          break;
       case stBRIDGESUBST:
          free_mem(&g_bridge_subst);
          g_bridge_sign=1;
          if(*sc_get_token(tmp)=='-'){
             g_bridge_sign=-1;
             sc_get_token(tmp);
          }else if(*tmp=='+')
             sc_get_token(tmp);
          if( (*tmp)!= ';' ){
             if(!set_in(*tmp,valid_id))
                halt(INVALIDBEGINOFID,tmp);
             g_bridge_subst=new_str(tmp);
             g_autosubst=1;
             if(*sc_get_token(tmp)!=';')
                halt(SEMICOLEXP,tmp);
          }else if(g_chord_subst==NULL)
             g_autosubst=0;
          state=stINIT;
          break;
       case stCHORDSUBST:
          free_mem(&g_chord_subst);
          g_chord_sign=1;
          if(*sc_get_token(tmp)=='-'){
             g_chord_sign=-1;
             sc_get_token(tmp);
          }else if(*tmp=='+')
             sc_get_token(tmp);
          if( (*tmp)!= ';' ){
             if(!set_in(*tmp,valid_id))
                halt(INVALIDBEGINOFID,tmp);
             g_chord_subst=new_str(tmp);
             g_autosubst=1;
             if(*sc_get_token(tmp)!=';')
                halt(SEMICOLEXP,tmp);
          }else if(g_bridge_subst==NULL)
             g_autosubst=0;
          state=stINIT;
          break;

       case stLOOPMOMENTA:
          if(s_scmp(sc_get_token(tmp),"momenta"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          {/*block*/

             int tmp_m[MAX_I_LINE],/* Nonsense, MAX_I_LINE does not relate to max. allowed
                                      group length! But, why not? It should be 1 - 2...*/
                 j;
             char ch[2]={'\0','\0'};
             g_max_loop_group=0;
             if(g_loopmomenta!=NULL){
                for(j=0; j<g_nloop; j++)
                      free(g_loopmomenta[j]);
                free_mem(&g_loopmomenta);
                g_nloop=0;
             }/*if(g_loopmomenta!=NULL)*/
             g_loopmomenta=get_mem(MAX_I_LINE,sizeof(int*));
             do{
                *tmp_m=0;
                do{
                   *ch=read_momentum_group(&j,tmp);
                   (*tmp_m)++;
                   if(!(*tmp_m<MAX_I_LINE))
                      halt(TOOMANYVECS,NULL);
                   tmp_m[*tmp_m]=j;
                }while(*ch=='\0');
                if((*ch==comma_char)||(*ch==';')){
                   if( (g_onlysimpleloopmomenta)&&((*tmp_m)!=1)  )
                       halt(ONLYELEMVEC,NULL);
                   g_loopmomenta[g_nloop]=new_int(tmp_m);
                   for(j=*tmp_m;j>0;j--)
                      if(g_max_loop_group<tmp_m[j])g_max_loop_group=tmp_m[j];

                   if(++g_nloop>=MAX_I_LINE)
                      halt(TOOMANYVECS,NULL);
                }else
                   halt(UNEXPECTED,ch);
                sc_get_token(tmp);/*Last token was pushed back by read_momentum_group*/
             }while(*ch!=';');
             free_mem(&g_loopmomenta_r);

             if( g_max_loop_group>0 ){
                int i;
                g_loopmomenta_r=get_mem( g_max_loop_group+1,sizeof(int));/*Filled up by 0*/
                for(i=0;i<g_nloop;i++)
                   for(j=*(g_loopmomenta[i]); j>0; j--)
                      g_loopmomenta_r[abs(g_loopmomenta[i][j])]=1;
             }/*if( g_max_loop_group>0 )*/
          }/*block*/
          state=stINIT;
          break;
       case stZEROMOMENTUM:
          if(s_scmp(sc_get_token(tmp),"momentum"))
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          {/*block*/
             int tmp_m[MAX_I_LINE],/* Nonsense, MAX_I_LINE does not relate to max. allowed
                                      group length! But, why not? It should be 1 - 2...*/
                 j;
             char ch[2]={'\0','\0'};
             char group[5];

             group[0]=3;group[1]=group[2]=1;group[3]='\n';group[4]=0;
             *tmp_m=0;
             do{
                *ch=read_momentum_group(&j,tmp);
                (*tmp_m)++;
                if(!(*tmp_m<MAX_I_LINE))
                   halt(TOOMANYVECS,NULL);
                tmp_m[*tmp_m]=j;
             }while(*ch=='\0');
             sc_get_token(tmp);/*Last token was pushed back by read_momentum_group*/

             if(*ch!=';')
                halt(SEMICOLEXP,ch);
             if(g_zeromomentum!=NULL)
                free(g_zeromomentum);
             g_zeromomentum=new_int(tmp_m);
             if(g_zeroVec!=NULL)free_mem(&g_zeroVec);

             g_zeroVec=new_str(build_momentum(group,g_zeromomentum,tmp, 1));
          }/*block*/
          state=stINIT;
          break;
       case stEXTERNAL:
          {char **thetype;
             if(s_scmp(sc_get_token(tmp),"coordinates"))
                halt(UNEXPECTED, tmp);
             if(!s_scmp(sc_get_token(tmp),"ev")) thetype=&g_ext_coords_ev;
             else if(!s_scmp(tmp,"evl")) thetype=&g_ext_coords_evl;
             else if(!s_scmp(tmp,"el")) thetype=&g_ext_coords_el;
             else if(!s_scmp(tmp,"ell")) thetype=&g_ext_coords_ell;
             else
                halt(UNEXPECTED, tmp);
             if(*sc_get_token(tmp)!='=')
                halt(EQUALEXP, tmp);
             if(*sc_get_token(tmp)=='"')
                 read_file_name(tmp);
             if( (*thetype)!=NULL) free(*thetype);
             *thetype=new_str(tmp);
          }
          state=stINIT;
          break;
       case stSORTBYTYPE:
          if(!s_scmp(sc_get_token(tmp),"enable"))
             g_sortByType=1;
          else if(!s_scmp(tmp,"disable"))
             g_sortByType=0;
          else
             halt(UNEXPECTED, tmp);
          state=stINIT;
          break;
       case stMAJORANA:
          /*
            see comment in pilot.c, seek direction_auto and direction_noauto
          */
          if(!s_scmp(sc_get_token(tmp),"enable"))
             direction=&direction_auto;
          else if(!s_scmp(tmp,"disable"))
             direction=&direction_noauto;
          else
             halt(UNEXPECTED, tmp);
          state=stINIT;
          break;
       case stNUMBER:
          if(s_scmp(sc_get_token(tmp),"of"))
             halt(UNEXPECTED, tmp);
          if(!s_scmp(sc_get_token(tmp),"functions")) state=stFUNCTIONSRESET;
          else if(!s_scmp(tmp,"commuting")) state=stCOMMUTINGRESET;
          else if(!s_scmp(tmp,"external")) state=stEXTERNALLINES;
          else if(!s_scmp(tmp,"vectors")) state=stVECTORSRESET;
          else if(!s_scmp(tmp,"topologies")) state=stTOPOLOGIESRESET;
          else if(!s_scmp(tmp,"prototypes")) state=stPROTOTYPESRESET;
          else if(!s_scmp(tmp,"id")) state=stIDRESET;
          else if(!s_scmp(tmp,"variables")) state=stVARIABLESRESET;
          else if(!s_scmp(tmp,"exports")) state=stEXPORTSRESET;
          else if(!s_scmp(tmp,"includes")) state=stINCLUDESRESET;
          else if(!s_scmp(tmp,"macroses")) state=stMACROSESRESET;
          else if(!s_scmp(tmp,"prepr_set")) state=stSET_RESET;
          else if(!s_scmp(tmp,"generic")) state=stGTOPOLOGIESRESET;
          else if(!s_scmp(tmp,"generated")) state=stMAXCOUPLINGORDER;
          else halt(UNEXPECTED, tmp);
          switch(state){
             case stEXTERNALLINES:
                if(ext_lines)
                   halt(DOUBLEEXT,NULL);
                if(s_scmp(sc_get_token(tmp),"lines"))
                   halt(UNEXPECTED,tmp);
                break;
             case stGTOPOLOGIESRESET:
                if(s_scmp(sc_get_token(tmp),"topologies"))
                   halt(UNEXPECTED,tmp);
                break;
             case stMAXCOUPLINGORDER:
                if(s_scmp(sc_get_token(tmp),"couplings"))
                   halt(UNEXPECTED,tmp);
                break;
          }/*switch(state)*/
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          num=str2long(sc_get_token(tmp));
          if (!(num>0))
             halt(INVALIDNUMBER,tmp);
          break;
       case stFUNCTIONS:
          if(all_functions_table!=NULL)
             halt(DOUBLEDEF,"functions");
          all_functions_table=create_hash_table(all_functions_hash_size,
                                              str_hash,str_cmp,c_destructor);
          do{
             state=read_to_comma(tmp);
             if(all_commuting_table!=NULL)
               if(lookup(tmp,all_commuting_table)!=NULL)
                  halt(DOUBLEDEF,tmp);
             ptr=new_str(tmp);
             if(install(ptr,ptr,all_functions_table))
                halt(DOUBLEDEF,tmp);
             max_top_identifiers++;
          }while(state);
          state=stINIT;
          break;
       case stCOMMUTING:
          if(all_commuting_table!=NULL)
             halt(DOUBLEDEF,"commuting");
          all_commuting_table=create_hash_table(all_commuting_hash_size,
                                              str_hash,str_cmp,c_destructor);
          do{
             state=read_to_comma(tmp);
             if(all_functions_table!=NULL)
                if(lookup(tmp,all_functions_table)!=NULL)
                   halt(DOUBLEDEF,tmp);
             ptr=new_str(tmp);
             if(install(ptr,ptr,all_commuting_table))
                halt(DOUBLEDEF,tmp);
             max_top_identifiers++;
          }while(state);
          state=stINIT;
          break;
       case stINDICES:
          {/* block begin*/
          int group=-1;
          sc_mark();
          if(*sc_get_token(tmp) == ':'){
             sc_release();
             sc_get_token(tmp);/* get the index group identifier*/
             for(state=0; state<numberOfIndicesGroups; state++){
                if(!s_scmp(tmp,index_id[state])){
                   group=state;break;
                }
             }/*for(state=0; state<numberOfIndicesGroups; state++)*/
            if(group<0)
               halt(UNDEFINEDINDICESGROUP,tmp);
          }else{
             sc_repeat();
             if(numberOfIndicesGroups<0){/* Not allocated yet*/
                /*Allocate default (first) group:*/
                numberOfIndicesGroups=1;
                allocate_indices_structures();
                index_id[0]=new_str(INDEX_ID);
             }/*if(numberOfIndicesGroups<0)*/
             group=0;
          }/*if(*sc_get_token(tmp) == ':')...else*/
          if (indices[group]!=NULL){
             sprintf(tmp,"indices:%s",index_id[group]);
             halt(DOUBLEDEF,tmp);
          }
          iNdex[group]=indices[group]=get_mem(1,sizeof(struct indices_struct ));
          iNdex[group]->next=NULL;
          iNdex[group]->id=NULL;
          do{
             state=read_to_comma(tmp);
             iNdex[group]->next=get_mem(1,sizeof(struct indices_struct ));
             iNdex[group]=iNdex[group]->next;
             iNdex[group]->next=NULL;
             iNdex[group]->id=new_str(tmp);
             if(max_ind_length<(indlen=s_len(tmp)))
                max_ind_length=indlen;
          }while(state);
          }/*block end*/
          state=stINIT;
          break;
       case stVECTORS:
          if(vectors_table==NULL)
              vectors_table=create_hash_table(vectors_hash_size,
                                              str_hash,str_cmp,c_destructor);
          do{
             state=read_to_comma(tmp);
             ptr=new_str(tmp);

             if(!install(ptr,ptr,vectors_table)){/*New id*/
                /*store it in the table:*/
                if(!(top_vec_id<max_top_vec_id))
                   if(
                      (vec_id=realloc(vec_id,
                         (max_top_vec_id+=MAX_VEC_GROUP)*sizeof(char*)))==NULL
                   )halt(NOTMEMORY,NULL);
                vec_id[top_vec_id++]=ptr;
             }/*if(!install(ptr,ptr,vectors_table))*/
          }while(state);
          state=stINIT;
          break;
       case stINGOING:
          if(main_id_table==NULL)
             halt(NOMODEL,NULL);
          mem_ext=ext_lines;
          ext_lines=0;
          read_ext_part(tmp,1);
          g_last_ingoing=ext_lines;
          state=stINIT;
          break;
       case stOUTGOING:
          if(main_id_table==NULL)
             halt(NOMODEL,NULL);
          if(ext_particles==NULL){
             if(!empty_external_item)
                halt(WHEREINGOING,NULL);
          }
          read_ext_part(tmp,0);
          if(ext_lines!=mem_ext)
             halt(EXTDISAGREE,NULL);
          {
           int i,c;
              /*Determining size of qgraf_ext:*/
              i=g_last_ingoing*2;
              c=(ext_lines-g_last_ingoing)*2+1;
              if (i>c) c=i;
              /* Allocate qgraf_ext:*/
              qgraf_ext=get_mem(c,sizeof(int));
              /* Fill by wrong characters:*/
              for(i=0;i<c;i++)
                 qgraf_ext[i]=-1;
              /* Set ingoing:*/
              for(i=1,c=0;c<g_last_ingoing;i+=2,c++)
                 qgraf_ext[i]=c;
              /* Set outgoing:*/
              for(i=2;c<ext_lines;i+=2,c++)
                 qgraf_ext[i]=c;
              /*Now if we find -1 -- this is error!*/
          }
          state=stINIT;
          break;

       case stTOPOLOGY:
          sc_mark();/*Check possible "topology table filename".*/
          /*The difficulties are due to the topology may have a name "table",
            so "topology table =" or "topology table ," relates to topology, not
            to a table!*/
          /*Extended: "table", "shapetable" or "momentatable"*/
          sc_get_token(tmp);
          {/*block*/
             int thechoice=0;
             if(s_scmp(tmp,"table")==0)thechoice=1;
             else if(s_scmp(tmp,"momentatable")==0)thechoice=2;
             else if(s_scmp(tmp,"shapetable")==0)thechoice=3;
             if(thechoice){
                thechoice--;
                switch(*sc_get_token(tmp)){
                   case '=':
                   case ',':/*Topology named "table"!*/
                      break;
                   default:
                      state=stINIT;
                      sc_release();/*safety, all we need it in tmp*/
                      if(*tmp == '"')read_file_name(tmp);
                      /*So, here we have in tmp the file name*/
                      /*If the current file name is started with '\1', this file required
                        only for momenta, if '\2', only for shape, otherwise, both.*/
                      if(thechoice){
                         char buf[2];
                         *buf=thechoice;buf[1]='\0';
                         g_ttnames=s_inc(g_ttnames,buf);
                      }/*if(thechoice)*/
                      /*Now add "fname:" to the end of g_ttnames:*/
                      g_ttnames=s_inc(s_inc(g_ttnames,tmp),":");
                      /*g_ttnames will be parsed in the function "main" (file "pilot.c"),
                         by calling the function read_topology_tables() (file "utils.c")*/
                }/*switch(*sc_get_token(tmp))*/
             }/*if(thechoice)*/
          }/*block*/
          if(state==stTOPOLOGY)
             sc_repeat();
          else
             break;/*there was "topology table"*/

          /*No break!*/
       case stGENERICTOPOLOGY:
          if(!ext_lines)
             halt(WHEREEXTPART,NULL);
          if(vectors_table==NULL)
            halt(UNDEFINED,"vectors");
          read_topology(state,tmp);
          state=stINIT;
          break;
       case stFERMION:
          if(s_scmp(sc_get_token(tmp),"direction")){
             if( s_scmp(tmp,"number")||
                 s_scmp(sc_get_token(tmp),"flow")
                 ) halt(UNEXPECTED, tmp);
             if(*sc_get_token(tmp)!='=')
                halt(EQUALEXP, tmp);
             uninstall(fflow_counter_id,id_replace_table);
             s_let(sc_get_token(tmp),fflow_counter_id);
             if( install(fflow_counter_id,fflow_counter_id,id_replace_table) )
                halt(IDALREADYUSED,fflow_counter_id);
             state=stINIT;
             break;
          }
          if(*sc_get_token(tmp)!='=')
             halt(EQUALEXP, tmp);
          if(!s_scmp(sc_get_token(tmp),"pa"))
             farrow=1;
          else if(!s_scmp(tmp,"ap"))
             farrow=-1;
          else
             halt(ONLIPAAP,tmp);
          state=stINIT;
          break;
       case stFUNCTIONSRESET:
          if(all_functions_table!=NULL)
             halt(CANNOTRESETTABLE,NULL);
          all_functions_hash_size=num;
          state=stINIT;
          break;
       case stCOMMUTINGRESET:
          if(all_commuting_table!=NULL)
             halt(CANNOTRESETTABLE,NULL);
          all_commuting_hash_size=num;
          state=stINIT;
          break;
       case stEXTERNALLINES:
          if(!((ext_lines=num)>0))
             halt(INVALIDNUMBER,tmp);
          state=stINIT;
          break;
       case stVECTORSRESET:
          if(vectors_table!=NULL)
             halt(CANNOTRESETTABLE,NULL);
          vectors_hash_size=num;
          state=stINIT;
          break;
       case stTOPOLOGIESRESET:
          if(
            (topology_id_table!=NULL)||
            (usertopologies_table!=NULL)||
            (nousertopologies_table!=NULL)
            ) halt(CANNOTRESETTABLE,NULL);
          topology_hash_size=num;
          state=stINIT;
          break;
       case stGTOPOLOGIESRESET:
          if(gtopology_id_table!=NULL)
             halt(CANNOTRESETTABLE,NULL);
          gtopology_hash_size=num;
          state=stINIT;
          break;
       case stMAXCOUPLINGORDER:
          max_order=num;
          state=stINIT;
          break;
       case stPROTOTYPESRESET:
          if(prototype_table!=NULL)
             halt(CANNOTRESETTABLE,NULL);
          prototype_hash_size=num;
          state=stINIT;
          break;
       case stIDRESET:
          if(main_id_table!=NULL)
             halt(CANNOTRESETTABLE,NULL);
          mainid_hash_size=num;
          state=stINIT;
          break;
       case stVARIABLESRESET:
          var_hash_size=num;
          state=stINIT;
          break;
       case stEXPORTSRESET:
          export_hash_size=num;
          state=stINIT;
          break;
       case stINCLUDESRESET:
          max_include=num;
          realloc_include();
          state=stINIT;
          break;
       case stMACROSESRESET:
          def_hash_size=num;
          state=stINIT;
          break;
       case stSET_RESET:
          set_hash_size=num;
          state=stINIT;
          break;
       case stSPECMODE:
          if(!s_scmp(sc_get_token(tmp),"begin"))
             state=stBEGINTRUNSLATE;
          else if(!s_scmp(tmp,"include")){
             include(get_inkl_name(tmp));
             state=stINIT;
          }else if(!s_scmp(tmp,"openlanguage")){
             include(get_inkl_name(tmp));
             state=stEND;
          }else
             halt(UNEXPECTED, tmp);
          break;
       case stBEGINTRUNSLATE:
          if(s_scmp(sc_get_token(tmp),"translate"))
             halt(UNEXPECTED, tmp);
          state=stEND;
          break;
       case stSELECT:
          state=0;
          if(!s_scmp(sc_get_token(tmp),"only"))
            set_bit(&state,0);
          else if(!s_scmp(tmp,"include"))
            set_bit(&state,1);
          else if(!s_scmp(tmp,"exclude"))
            set_bit(&state,2);
          else
             halt(UNEXPECTED, tmp);
          if(!s_scmp(sc_get_token(tmp),"particle")){
             set_bit(&state,3);
          }else if(!s_scmp(tmp,"vertex"))
             set_bit(&state,4);
          else
             halt(UNEXPECTED, tmp);
          if(*sc_get_token(tmp) != '(')
             halt(OBRACKEDEXPECTED,tmp);
          if(is_bit_set(&state,0)){word i;
             for (i=0;i<top_id;i++)
                if (is_bit_set(&state,3)){/*clear propagators*/
                   if(id[i].id[0]==2)set_bit(&(id[i].skip),0);
                }else{/*clear vertices*/
                   if(id[i].id[0]>2)set_bit(&(id[i].skip),0);
                }
          }else if(is_bit_set(&state,1)){;
             if (is_bit_set(&state,3)){/*clear propagators*/
                if(waspinclude)halt(ONLYONEINCLUDESECTION,NULL);
                waspinclude=1;
             }else{/*clear vertices*/
                if(wasvinclude)halt(ONLYONEINCLUDESECTION,NULL);
                wasvinclude=1;
             }
          }

          if(is_bit_set(&state,3)){int r;word *ptr;/*propagator*/
             do{
                r=read_to_comma_or_bracket(tmp);
                if ( (ptr=lookup(s_cat(tmp,"\1",tmp),main_id_table))==NULL)
                    halt(UNDEFINEDID,m2s(tmp));
                if(!(id[*ptr].link[1] <top_id))
                   halt(UNDEFINEDID,m2s(tmp));
                if (is_bit_set(&state,2))
                  set_bit(&(id[ id[*ptr].link[1] ].skip),0);
                else if(is_bit_set(&state,1)){
                  if(!is_bit_set(&(id[ id[*ptr].link[1] ].skip),1)){
                     set_bit(&(id[ id[*ptr].link[1] ].skip),1);
                     includeparticletop++;
                  }
                }else
                   unset_bit(&(id[ id[*ptr].link[1] ].skip),0);
             }while(r==1);
          }else{int r;char buf[MAX_STR_LEN];word *ptr;/*vertex*/
             do{
                *buf=0;
                do{
                   r=read_to_comma_or_bracket(tmp);
                   m_cat(buf,buf,s_cat(tmp,"\1",tmp));
                }while(r==1);
                if ( (ptr=lookup(buf,main_id_table))==NULL)
                    halt(UNDEFINEDID,m2s(buf));
                if (is_bit_set(&state,2))
                  set_bit(&(id[*ptr].skip),0);
                else if(is_bit_set(&state,1)){
                  if (!is_bit_set(&(id[*ptr].skip),1)){
                     set_bit(&(id[*ptr].skip),1);
                     includeparticletop++;
                  }
                }else
                  unset_bit(&(id[*ptr].skip),0);
             }while(r);
          }
          state=stINIT;
          break;
    }/*End finite automaton*/

    for(state=0;state<MAX_LINES_IN_VERTEX;state++)
       free_mem(&(current_particles[state]));
    free_mem(&(current_particles));

    for(state=0; state<top_topol; state++){
       check_topology_coordinates(topologies+state);
       if(topologies[state].coordinates_ok)
          calculate_topology_coordinates(topologies+state);
    }/*for(state=0; state<top_topol; state++)*/
    if(!is_bit_set(&mode,bitONLYINTERPRET)){
       if(input_name==NULL)
          halt(WHEREINPUT,NULL);
       identifiers=get_mem(max_top_identifiers,
                         sizeof(struct identifiers_structure )
                       );
    }/*if(!is_bit_set(&mode,bitONLYINTERPRET))*/
    if(includeparticletop){
       includeparticle=get_mem(includeparticletop,sizeof(word));
       indlen=0;
       for(state=0;state<top_id;state++)
          if (is_bit_set(&(id[state].skip),1)){
             if(!(indlen<includeparticletop))
                halt(INTERNALERROR,NULL);
              includeparticle[indlen++]=state;
          }
    }/*if(includeparticletop)*/
    if(top_gtopol != 0 ){/* There are at least one generic topology*/
       for(gtop_n_generic=0;gtop_n_generic<top_gtopol; gtop_n_generic++){
          get_topologies_from_generic(tmp);/* static*/
       }/*for(gtop_n_generic=0;gtop_n_generic<top_gtopol; gtop_n_generic++)*/
       clear_gtopologies_tables();
    }/*(top_gtopol != 0 )*/
    hash_table_done(id_replace_table);
}/*read_config_file_before_truns*/

void cnf_read_done(void)
{
  word i;
   free_mem(&identifiers);
   if(index_id!=NULL){
      for(i=0; i<numberOfIndicesGroups;i++)
         free_mem(&(index_id[i]));
      free_mem(&index_id);
   }
   if(indices!=NULL){
      for(i=0; i<numberOfIndicesGroups;i++){
         while(indices[i]!=NULL){
            iNdex[0]=indices[i]->next;
            free_mem(&(indices[i]->id));
            free_mem(&(indices[i]));
            indices[i]=iNdex[0];
         }/*while(indices[i]!=NULL)*/
      }/*for(i=0; i<numberOfIndicesGroups;i++)*/
      free_mem(&indices);
   }/*if(indices!=NULL)*/
   free_mem(&iNdex);
   for(i=0;i<top_id;i++){
      free_mem(&(id[i].mass));
      free_mem(&(id[i].form_id));
      free_mem(&(id[i].id));
   }
   free_mem(&id);

   for(i=1;i<top_vec_group;i++){
      free_mem(&(vec_group[i].vec));
      free_mem(&(vec_group[i].text));
   }
   free_mem(&vec_group);
   if(ext_particles!=NULL){
       for(i=0;i<ext_lines;i++){
          free_mem(&(ext_particles[i].momentum));
          free_mem(&(ext_particles[i].ind));
          free_mem(&(ext_particles[i].id));
       }
       free_mem(&ext_particles);
   }
   free_mem(&qgraf_ext);

   for(i=0;i<top_topol;i++)
      clear_topology(topologies,i);

  free_mem(&topologies);

  clear_gtopologies_tables();

  if (current_particles!=NULL)
     for(i=0;i<MAX_LINES_IN_VERTEX;i++)
        free_mem(&(current_particles[i]));
  free_mem(&(current_particles));
}/*cnf_read_done*/

int is_digits(char *str)/*returns 1 if all chars are digits.*/
{
  while(*str)
     if(!set_in(*str++,digits))return(0);
  return(1);
}/*is_digits*/

void check_momenta_balance_on_each_topology(void)
{
char str[MAX_STR_LEN];
word i,nWrong=0;
int j,k;
       for(i=0; i<top_topol; i++)
           for(j=0; j<topologies[i].n_momenta; j++)
              if(
                 *checkTopMomentaBalance(str,topologies,i,j)!='\0'
              ){
                 char tmp[MAX_STR_LEN];
                 char *ptr=tmp;
                 char subst[MAX_VERTEX+2];
                 nWrong++;
                 invertsubstitution(subst,topologies[i].v_subst);
                 /*ATTENTION! No overflow checking!:*/
                 for(k=0; str[k]!='\0'; k++){
                    sprintf(ptr,"%d,",subst[str[k]]);
                    while(*ptr!='\0')ptr++;
                 }/*for(k=0; str[k]!='\0'; k++)*/
                 *--ptr='\0';
                 if(  is_bit_set(&mode,bitFIRSTCHECKBALANCE)  )
                    halt(WRONGMOMENTABALANCE,i+1,topologies[i].id[0],j+1,tmp);
                 else
                    message(WRONGMOMENTABALANCE,i+1,topologies[i].id[0],j+1,tmp);
              }/*if(...)*/
       if(nWrong!=0){
          if(  is_bit_set(&mode,bitTHROUGHCHECKBALANCE)  ){
             message(WASWRONGMOMENTABALANCE,nWrong);
          }else
             halt(HALTWASWRONGMOMENTABALANCE,nWrong);
       }/*if(nWrong!=0)*/
}/*check_momenta_balance_on_each_topology*/
